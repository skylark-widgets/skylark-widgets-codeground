{"version":3,"sources":["addon/fold/comment-fold.js"],"names":["define","CodeMirror","registerGlobalHelper","mode","blockCommentStart","blockCommentEnd","cm","start","getModeAt","startToken","endToken","startCh","line","lineText","getLine","at","ch","pass","found","lastIndexOf","test","getTokenTypeAt","Pos","slice","length","end","endCh","depth","lastLine","outer","i","text","pos","nextOpen","indexOf","nextClose","Math","min","from","to"],"mappings":";;;;;;;AAGAA,QAAQ,eAAgB,SAASC,GACjC,YAEAA,GAAWC,qBAAqB,OAAQ,UAAW,SAASC,GAC1D,MAAOA,GAAKC,mBAAqBD,EAAKE,iBACrC,SAASC,EAAIC,GACd,GAAIJ,GAAOG,EAAGE,UAAUD,GAAQE,EAAaN,EAAKC,kBAAmBM,EAAWP,EAAKE,eACrF,IAAKI,GAAeC,EAApB,CAIA,IAAK,GADDC,GAFAC,EAAOL,EAAMK,KAAMC,EAAWP,EAAGQ,QAAQF,GAGpCG,EAAKR,EAAMS,GAAIC,EAAO,IAAK,CAClC,GAAIC,GAAQH,GAAM,KAASF,EAASM,YAAYV,EAAYM,EAAK,EACjE,IAAIG,MAAJ,CAMA,GAAY,GAARD,GAAaC,EAAQX,EAAMS,GAAI,MACnC,IAAI,UAAUI,KAAKd,EAAGe,eAAepB,EAAWqB,IAAIV,EAAMM,EAAQ,OACpD,GAATA,GAAcL,EAASU,MAAML,EAAQR,EAASc,OAAQN,IAAUR,IAC/D,UAAUU,KAAKd,EAAGe,eAAepB,EAAWqB,IAAIV,EAAMM,MAAW,CACrEP,EAAUO,EAAQT,EAAWe,MAC7B,OAEFT,EAAKG,EAAQ,MAbb,CACE,GAAY,GAARD,EAAW,MACfA,GAAO,EACPF,EAAKF,EAASW,QAalB,GAAyCC,GAAKC,EAA1CC,EAAQ,EAAGC,EAAWtB,EAAGsB,UAC7BC,GAAO,IAAK,GAAIC,GAAIlB,EAAMkB,GAAKF,IAAYE,EAEzC,IADA,GAAIC,GAAOzB,EAAGQ,QAAQgB,GAAIE,EAAMF,GAAKlB,EAAOD,EAAU,IAC7C,CACP,GAAIsB,GAAWF,EAAKG,QAAQzB,EAAYuB,GAAMG,EAAYJ,EAAKG,QAAQxB,EAAUsB,EAIjF,IAHIC,EAAW,IAAGA,EAAWF,EAAKP,QAC9BW,EAAY,IAAGA,EAAYJ,EAAKP,QACpCQ,EAAMI,KAAKC,IAAIJ,EAAUE,GACrBH,GAAOD,EAAKP,OAAQ,KACxB,IAAIQ,GAAOC,IAAYN,MAClB,OAAOA,EAAO,CAAEF,EAAMK,EAAGJ,EAAQM,CAAK,MAAMH,KAC/CG,EAGN,GAAW,MAAPP,IAAeb,GAAQa,GAAOC,GAASf,GAC3C,OAAQ2B,KAAMrC,EAAWqB,IAAIV,EAAMD,GAC3B4B,GAAItC,EAAWqB,IAAIG,EAAKC","file":"../../../addon/fold/comment-fold.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerGlobalHelper(\"fold\", \"comment\", function(mode) {\n  return mode.blockCommentStart && mode.blockCommentEnd;\n}, function(cm, start) {\n  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;\n  if (!startToken || !endToken) return;\n  var line = start.line, lineText = cm.getLine(line);\n\n  var startCh;\n  for (var at = start.ch, pass = 0;;) {\n    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);\n    if (found == -1) {\n      if (pass == 1) return;\n      pass = 1;\n      at = lineText.length;\n      continue;\n    }\n    if (pass == 1 && found < start.ch) return;\n    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1))) &&\n        (found == 0 || lineText.slice(found - endToken.length, found) == endToken ||\n         !/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found))))) {\n      startCh = found + startToken.length;\n      break;\n    }\n    at = found - 1;\n  }\n\n  var depth = 1, lastLine = cm.lastLine(), end, endCh;\n  outer: for (var i = line; i <= lastLine; ++i) {\n    var text = cm.getLine(i), pos = i == line ? startCh : 0;\n    for (;;) {\n      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);\n      if (nextOpen < 0) nextOpen = text.length;\n      if (nextClose < 0) nextClose = text.length;\n      pos = Math.min(nextOpen, nextClose);\n      if (pos == text.length) break;\n      if (pos == nextOpen) ++depth;\n      else if (!--depth) { end = i; endCh = pos; break outer; }\n      ++pos;\n    }\n  }\n  if (end == null || line == end && endCh == startCh) return;\n  return {from: CodeMirror.Pos(line, startCh),\n          to: CodeMirror.Pos(end, endCh)};\n});\n\n});\n"]}