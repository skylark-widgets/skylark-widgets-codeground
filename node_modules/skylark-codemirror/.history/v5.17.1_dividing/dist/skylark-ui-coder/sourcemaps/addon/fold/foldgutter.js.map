{"version":3,"sources":["addon/fold/foldgutter.js"],"names":["define","CodeMirror","State","options","this","from","to","parseOptions","opts","gutter","indicatorOpen","indicatorFolded","isFolded","cm","line","marks","findMarks","Pos","i","length","__isFold","find","marker","spec","elt","document","createElement","className","cloneNode","updateFoldInfo","state","foldGutter","cur","minSize","foldOption","func","eachLine","mark","pos","range","setGutterMarker","updateInViewport","vp","getViewport","operation","onGutterClick","folded","clear","foldCode","rangeFinder","onChange","clearTimeout","changeUpdate","setTimeout","foldOnChangeTimeSpan","onViewportChange","updateViewportTimeSpan","onFold","defineOption","val","old","Init","clearGutter","off","on"],"mappings":"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","file":"../../../addon/fold/foldgutter.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\",\"./foldcode\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"foldGutter\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      cm.clearGutter(cm.state.foldGutter.options.gutter);\n      cm.state.foldGutter = null;\n      cm.off(\"gutterClick\", onGutterClick);\n      cm.off(\"change\", onChange);\n      cm.off(\"viewportChange\", onViewportChange);\n      cm.off(\"fold\", onFold);\n      cm.off(\"unfold\", onFold);\n      cm.off(\"swapDoc\", onChange);\n    }\n    if (val) {\n      cm.state.foldGutter = new State(parseOptions(val));\n      updateInViewport(cm);\n      cm.on(\"gutterClick\", onGutterClick);\n      cm.on(\"change\", onChange);\n      cm.on(\"viewportChange\", onViewportChange);\n      cm.on(\"fold\", onFold);\n      cm.on(\"unfold\", onFold);\n      cm.on(\"swapDoc\", onChange);\n    }\n  });\n\n  var Pos = CodeMirror.Pos;\n\n  function State(options) {\n    this.options = options;\n    this.from = this.to = 0;\n  }\n\n  function parseOptions(opts) {\n    if (opts === true) opts = {};\n    if (opts.gutter == null) opts.gutter = \"CodeMirror-foldgutter\";\n    if (opts.indicatorOpen == null) opts.indicatorOpen = \"CodeMirror-foldgutter-open\";\n    if (opts.indicatorFolded == null) opts.indicatorFolded = \"CodeMirror-foldgutter-folded\";\n    return opts;\n  }\n\n  function isFolded(cm, line) {\n    var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));\n    for (var i = 0; i < marks.length; ++i)\n      if (marks[i].__isFold && marks[i].find().from.line == line) return marks[i];\n  }\n\n  function marker(spec) {\n    if (typeof spec == \"string\") {\n      var elt = document.createElement(\"div\");\n      elt.className = spec + \" CodeMirror-guttermarker-subtle\";\n      return elt;\n    } else {\n      return spec.cloneNode(true);\n    }\n  }\n\n  function updateFoldInfo(cm, from, to) {\n    var opts = cm.state.foldGutter.options, cur = from;\n    var minSize = cm.foldOption(opts, \"minFoldSize\");\n    var func = cm.foldOption(opts, \"rangeFinder\");\n    cm.eachLine(from, to, function(line) {\n      var mark = null;\n      if (isFolded(cm, cur)) {\n        mark = marker(opts.indicatorFolded);\n      } else {\n        var pos = Pos(cur, 0);\n        var range = func && func(cm, pos);\n        if (range && range.to.line - range.from.line >= minSize)\n          mark = marker(opts.indicatorOpen);\n      }\n      cm.setGutterMarker(line, opts.gutter, mark);\n      ++cur;\n    });\n  }\n\n  function updateInViewport(cm) {\n    var vp = cm.getViewport(), state = cm.state.foldGutter;\n    if (!state) return;\n    cm.operation(function() {\n      updateFoldInfo(cm, vp.from, vp.to);\n    });\n    state.from = vp.from; state.to = vp.to;\n  }\n\n  function onGutterClick(cm, line, gutter) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    if (gutter != opts.gutter) return;\n    var folded = isFolded(cm, line);\n    if (folded) folded.clear();\n    else cm.foldCode(Pos(line, 0), opts.rangeFinder);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    state.from = state.to = 0;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);\n  }\n\n  function onViewportChange(cm) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var opts = state.options;\n    clearTimeout(state.changeUpdate);\n    state.changeUpdate = setTimeout(function() {\n      var vp = cm.getViewport();\n      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {\n        updateInViewport(cm);\n      } else {\n        cm.operation(function() {\n          if (vp.from < state.from) {\n            updateFoldInfo(cm, vp.from, state.from);\n            state.from = vp.from;\n          }\n          if (vp.to > state.to) {\n            updateFoldInfo(cm, state.to, vp.to);\n            state.to = vp.to;\n          }\n        });\n      }\n    }, opts.updateViewportTimeSpan || 400);\n  }\n\n  function onFold(cm, from) {\n    var state = cm.state.foldGutter;\n    if (!state) return;\n    var line = from.line;\n    if (line >= state.from && line < state.to)\n      updateFoldInfo(cm, line, line + 1);\n  }\n});\n"]}