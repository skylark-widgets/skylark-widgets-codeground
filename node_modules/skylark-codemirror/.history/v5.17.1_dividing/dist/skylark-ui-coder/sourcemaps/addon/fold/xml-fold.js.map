{"version":3,"sources":["addon/fold/xml-fold.js"],"names":["define","CodeMirror","cmp","a","b","line","ch","Iter","cm","range","this","text","getLine","min","from","firstLine","max","to","lastLine","tagAt","iter","type","getTokenTypeAt","Pos","test","nextLine","prevLine","length","toTagEnd","gt","indexOf","lastSlash","lastIndexOf","selfClose","slice","toTagStart","lt","xmlTagStart","lastIndex","match","exec","index","toNextTag","found","toPrevTag","findMatchingClose","tag","stack","end","next","startLine","startCh","i","push","findMatchingOpen","prev","endLine","endCh","start","nameStartChar","nameChar","RegExp","registerHelper","openTag","startPos","endPos","findMatchingTag","pos","here","open","close","at","findEnclosingTag","forward","scanForClosingTag","name"],"mappings":"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","file":"../../../addon/fold/xml-fold.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  \"use strict\";\n\n  var Pos = CodeMirror.Pos;\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\n\n  var nameStartChar = \"A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n  var nameChar = nameStartChar + \"\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n  var xmlTagStart = new RegExp(\"<(/?)([\" + nameStartChar + \"][\" + nameChar + \"]*)\", \"g\");\n\n  function Iter(cm, line, ch, range) {\n    this.line = line; this.ch = ch;\n    this.cm = cm; this.text = cm.getLine(line);\n    this.min = range ? range.from : cm.firstLine();\n    this.max = range ? range.to - 1 : cm.lastLine();\n  }\n\n  function tagAt(iter, ch) {\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\n    return type && /\\btag\\b/.test(type);\n  }\n\n  function nextLine(iter) {\n    if (iter.line >= iter.max) return;\n    iter.ch = 0;\n    iter.text = iter.cm.getLine(++iter.line);\n    return true;\n  }\n  function prevLine(iter) {\n    if (iter.line <= iter.min) return;\n    iter.text = iter.cm.getLine(--iter.line);\n    iter.ch = iter.text.length;\n    return true;\n  }\n\n  function toTagEnd(iter) {\n    for (;;) {\n      var gt = iter.text.indexOf(\">\", iter.ch);\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n  function toTagStart(iter) {\n    for (;;) {\n      var lt = iter.ch ? iter.text.lastIndexOf(\"<\", iter.ch - 1) : -1;\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\n      xmlTagStart.lastIndex = lt;\n      iter.ch = lt;\n      var match = xmlTagStart.exec(iter.text);\n      if (match && match.index == lt) return match;\n    }\n  }\n\n  function toNextTag(iter) {\n    for (;;) {\n      xmlTagStart.lastIndex = iter.ch;\n      var found = xmlTagStart.exec(iter.text);\n      if (!found) { if (nextLine(iter)) continue; else return; }\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\n      iter.ch = found.index + found[0].length;\n      return found;\n    }\n  }\n  function toPrevTag(iter) {\n    for (;;) {\n      var gt = iter.ch ? iter.text.lastIndexOf(\">\", iter.ch - 1) : -1;\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\n      var lastSlash = iter.text.lastIndexOf(\"/\", gt);\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\n      iter.ch = gt + 1;\n      return selfClose ? \"selfClose\" : \"regular\";\n    }\n  }\n\n  function findMatchingClose(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\n      if (!next || !(end = toTagEnd(iter))) return;\n      if (end == \"selfClose\") continue;\n      if (next[1]) { // closing tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == next[2])) return {\n          tag: next[2],\n          from: Pos(startLine, startCh),\n          to: Pos(iter.line, iter.ch)\n        };\n      } else { // opening tag\n        stack.push(next[2]);\n      }\n    }\n  }\n  function findMatchingOpen(iter, tag) {\n    var stack = [];\n    for (;;) {\n      var prev = toPrevTag(iter);\n      if (!prev) return;\n      if (prev == \"selfClose\") { toTagStart(iter); continue; }\n      var endLine = iter.line, endCh = iter.ch;\n      var start = toTagStart(iter);\n      if (!start) return;\n      if (start[1]) { // closing tag\n        stack.push(start[2]);\n      } else { // opening tag\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\n          stack.length = i;\n          break;\n        }\n        if (i < 0 && (!tag || tag == start[2])) return {\n          tag: start[2],\n          from: Pos(iter.line, iter.ch),\n          to: Pos(endLine, endCh)\n        };\n      }\n    }\n  }\n\n  CodeMirror.registerHelper(\"fold\", \"xml\", function(cm, start) {\n    var iter = new Iter(cm, start.line, 0);\n    for (;;) {\n      var openTag = toNextTag(iter), end;\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\n      if (!openTag[1] && end != \"selfClose\") {\n        var startPos = Pos(iter.line, iter.ch);\n        var endPos = findMatchingClose(iter, openTag[2]);\n        return endPos && {from: startPos, to: endPos.from};\n      }\n    }\n  });\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    if (iter.text.indexOf(\">\") == -1 && iter.text.indexOf(\"<\") == -1) return;\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\n    var start = end && toTagStart(iter);\n    if (!end || !start || cmp(iter, pos) > 0) return;\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\n    if (end == \"selfClose\") return {open: here, close: null, at: \"open\"};\n\n    if (start[1]) { // closing tag\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: \"close\"};\n    } else { // opening tag\n      iter = new Iter(cm, to.line, to.ch, range);\n      return {open: here, close: findMatchingClose(iter, start[2]), at: \"open\"};\n    }\n  };\n\n  CodeMirror.findEnclosingTag = function(cm, pos, range) {\n    var iter = new Iter(cm, pos.line, pos.ch, range);\n    for (;;) {\n      var open = findMatchingOpen(iter);\n      if (!open) break;\n      var forward = new Iter(cm, pos.line, pos.ch, range);\n      var close = findMatchingClose(forward, open.tag);\n      if (close) return {open: open, close: close};\n    }\n  };\n\n  // Used by addon/edit/closetag.js\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\n    return findMatchingClose(iter, name);\n  };\n});\n"]}