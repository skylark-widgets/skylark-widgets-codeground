{"version":3,"sources":["addon/hint/javascript-hint.js"],"names":["define","CodeMirror","forEach","arr","f","i","e","length","arrayContains","item","Array","prototype","indexOf","scriptHint","editor","keywords","getToken","options","cur","getCursor","token","test","type","state","innerMode","getMode","string","end","ch","slice","start","tprop","Pos","line","context","push","list","getCompletions","from","to","javascriptHint","javascriptKeywords","getTokenAt","getCoffeeScriptToken","charAt","replace","coffeescriptHint","coffeescriptKeywords","maybeAdd","str","lastIndexOf","found","gatherCompletions","obj","stringProps","arrayProps","Function","funcProps","name","global","globalScope","window","base","pop","additionalContext","useGlobalScope","jQuery","_","v","localVars","next","globalVars","registerHelper","split"],"mappings":"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","file":"../../../addon/hint/javascript-hint.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur);\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n               type: token.string == \".\" ? \"property\" : null};\n    } else if (token.end > cur.ch) {\n      token.end = cur.ch;\n      token.string = token.string.slice(0, cur.ch - token.start);\n    }\n\n    var tprop = token;\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string, global = options && options.globalScope || window;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      for (var name in obj) maybeAdd(name);\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        if (!options || options.useGlobalScope !== false)\n          base = base || global[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (global.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof global.jQuery == 'function'))\n          base = global.jQuery();\n        else if (global._ != null && (obj.string == '_') && (typeof global._ == 'function'))\n          base = global._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the global object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      if (!options || options.useGlobalScope !== false)\n        gatherCompletions(global);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n});\n"]}