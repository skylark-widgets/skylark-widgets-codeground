{"version":3,"sources":["addon/mode/multiplex.js"],"names":["define","CodeMirror","multiplexingMode","outer","indexOf","string","pattern","from","returnEnd","found","length","m","exec","slice","index","others","Array","prototype","call","arguments","startState","innerActive","inner","copyState","state","mode","token","stream","curInner","oldContent","close","sol","this","pos","parseDelimiters","match","delimStyle","innerToken","innerStyle","cutOff","Infinity","i","other","open","indent","outerToken","textAfter","Pass","blankLine","electricChars","innerMode"],"mappings":"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","file":"../../../addon/mode/multiplex.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.multiplexingMode = function(outer /*, others */) {\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n  var others = Array.prototype.slice.call(arguments, 1);\n\n  function indexOf(string, pattern, from, returnEnd) {\n    if (typeof pattern == \"string\") {\n      var found = string.indexOf(pattern, from);\n      return returnEnd && found > -1 ? found + pattern.length : found;\n    }\n    var m = pattern.exec(from ? string.slice(from) : string);\n    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n  }\n\n  return {\n    startState: function() {\n      return {\n        outer: CodeMirror.startState(outer),\n        innerActive: null,\n        inner: null\n      };\n    },\n\n    copyState: function(state) {\n      return {\n        outer: CodeMirror.copyState(outer, state.outer),\n        innerActive: state.innerActive,\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n      };\n    },\n\n    token: function(stream, state) {\n      if (!state.innerActive) {\n        var cutOff = Infinity, oldContent = stream.string;\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          var found = indexOf(oldContent, other.open, stream.pos);\n          if (found == stream.pos) {\n            if (!other.parseDelimiters) stream.match(other.open);\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, \"\") : 0);\n            return other.delimStyle && (other.delimStyle + \" \" + other.delimStyle + \"-open\");\n          } else if (found != -1 && found < cutOff) {\n            cutOff = found;\n          }\n        }\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n        var outerToken = outer.token(stream, state.outer);\n        if (cutOff != Infinity) stream.string = oldContent;\n        return outerToken;\n      } else {\n        var curInner = state.innerActive, oldContent = stream.string;\n        if (!curInner.close && stream.sol()) {\n          state.innerActive = state.inner = null;\n          return this.token(stream, state);\n        }\n        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n        if (found == stream.pos && !curInner.parseDelimiters) {\n          stream.match(curInner.close);\n          state.innerActive = state.inner = null;\n          return curInner.delimStyle && (curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\");\n        }\n        if (found > -1) stream.string = oldContent.slice(0, found);\n        var innerToken = curInner.mode.token(stream, state.inner);\n        if (found > -1) stream.string = oldContent;\n\n        if (found == stream.pos && curInner.parseDelimiters)\n          state.innerActive = state.inner = null;\n\n        if (curInner.innerStyle) {\n          if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;\n          else innerToken = curInner.innerStyle;\n        }\n\n        return innerToken;\n      }\n    },\n\n    indent: function(state, textAfter) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (!mode.indent) return CodeMirror.Pass;\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);\n    },\n\n    blankLine: function(state) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (mode.blankLine) {\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\n      }\n      if (!state.innerActive) {\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          if (other.open === \"\\n\") {\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\") : 0);\n          }\n        }\n      } else if (state.innerActive.close === \"\\n\") {\n        state.innerActive = state.inner = null;\n      }\n    },\n\n    electricChars: outer.electricChars,\n\n    innerMode: function(state) {\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\n    }\n  };\n};\n\n});\n"]}