{"version":3,"sources":["addon/search/match-highlighter.js"],"names":["define","CodeMirror","State","options","this","name","defaults","hasOwnProperty","overlay","timeout","matchesonscroll","cursorActivity","cm","state","matchHighlighter","clearTimeout","setTimeout","highlightMatches","delay","addOverlay","query","hasBoundary","style","makeOverlay","annotateScrollbar","showMatchesOnScrollbar","searchFor","RegExp","className","removeOverlay","clear","operation","somethingSelected","showToken","re","cur","getCursor","line","getLine","start","ch","end","test","charAt","length","slice","from","to","wordsOnly","isWord","selection","getRange","trim","replace","minChars","str","match","pos","chr","boundariesAround","stream","string","token","next","skipTo","skipToEnd","defineOption","val","old","Init","off","on"],"mappings":"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","file":"../../../addon/search/match-highlighter.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, wordsOnly, showToken, delay} object to explicitly\n// configure it. minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. If wordsOnly is enabled, the matches will be\n// highlighted only if the selected text is a word. showToken, when enabled,\n// will cause the current token to be highlighted when nothing is selected.\n// delay is used to specify how much time to wait, in milliseconds, before\n// highlighting the matches. If annotateScrollbar is enabled, the occurences\n// will be highlighted on the scrollbar via the matchesonscrollbar addon.\n\ndefine([\"../../Coder\", \"./matchesonscrollbar\"], function(CodeMirror) {\n  \"use strict\";\n\n  var defaults = {\n    style: \"matchhighlight\",\n    minChars: 2,\n    delay: 100,\n    wordsOnly: false,\n    annotateScrollbar: false,\n    showToken: false,\n    trim: true\n  }\n\n  function State(options) {\n    this.options = {}\n    for (var name in defaults)\n      this.options[name] = (options && options.hasOwnProperty(name) ? options : defaults)[name]\n    this.overlay = this.timeout = null;\n    this.matchesonscroll = null;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      removeOverlay(cm);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n    }\n    if (val) {\n      cm.state.matchHighlighter = new State(val);\n      highlightMatches(cm);\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.options.delay);\n  }\n\n  function addOverlay(cm, query, hasBoundary, style) {\n    var state = cm.state.matchHighlighter;\n    cm.addOverlay(state.overlay = makeOverlay(query, hasBoundary, style));\n    if (state.options.annotateScrollbar && cm.showMatchesOnScrollbar) {\n      var searchFor = hasBoundary ? new RegExp(\"\\\\b\" + query + \"\\\\b\") : query;\n      state.matchesonscroll = cm.showMatchesOnScrollbar(searchFor, false,\n        {className: \"CodeMirror-selection-highlight-scrollbar\"});\n    }\n  }\n\n  function removeOverlay(cm) {\n    var state = cm.state.matchHighlighter;\n    if (state.overlay) {\n      cm.removeOverlay(state.overlay);\n      state.overlay = null;\n      if (state.matchesonscroll) {\n        state.matchesonscroll.clear();\n        state.matchesonscroll = null;\n      }\n    }\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      removeOverlay(cm);\n      if (!cm.somethingSelected() && state.options.showToken) {\n        var re = state.options.showToken === true ? /[\\w$]/ : state.options.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          addOverlay(cm, line.slice(start, end), re, state.options.style);\n        return;\n      }\n      var from = cm.getCursor(\"from\"), to = cm.getCursor(\"to\");\n      if (from.line != to.line) return;\n      if (state.options.wordsOnly && !isWord(cm, from, to)) return;\n      var selection = cm.getRange(from, to)\n      if (state.options.trim) selection = selection.replace(/^\\s+|\\s+$/g, \"\")\n      if (selection.length >= state.options.minChars)\n        addOverlay(cm, selection, false, state.options.style);\n    });\n  }\n\n  function isWord(cm, from, to) {\n    var str = cm.getRange(from, to);\n    if (str.match(/^\\w+$/) !== null) {\n        if (from.ch > 0) {\n            var pos = {line: from.line, ch: from.ch - 1};\n            var chr = cm.getRange(pos, from);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        if (to.ch < cm.getLine(from.line).length) {\n            var pos = {line: to.line, ch: to.ch + 1};\n            var chr = cm.getRange(to, pos);\n            if (chr.match(/\\W/) === null) return false;\n        }\n        return true;\n    } else return false;\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n});\n"]}