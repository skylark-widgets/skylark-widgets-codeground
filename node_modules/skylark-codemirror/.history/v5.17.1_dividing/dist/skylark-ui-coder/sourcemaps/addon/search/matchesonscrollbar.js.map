{"version":3,"sources":["addon/search/matchesonscrollbar.js"],"names":["define","CodeMirror","SearchAnnotation","cm","query","caseFold","options","this","annotateOptions","listenForChanges","prop","className","annotation","annotateScrollbar","gap","from","firstLine","to","lastLine","matches","update","findMatches","self","on","changeHandler","_cm","change","onChange","offsetLine","line","changeStart","sizeChange","Math","max","defineExtension","MAX_MATCHES","prototype","i","length","match","splice","cursor","getSearchCursor","Pos","maxMatches","findNext","startLine","endLine","changeEnd","min","newFrom","ch","newTo","clearTimeout","setTimeout","updateAfterChange","clear","off"],"mappings":"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","file":"../../../addon/search/matchesonscrollbar.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\", \"./searchcursor\", \"../scroll/annotatescrollbar\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineExtension(\"showMatchesOnScrollbar\", function(query, caseFold, options) {\n    if (typeof options == \"string\") options = {className: options};\n    if (!options) options = {};\n    return new SearchAnnotation(this, query, caseFold, options);\n  });\n\n  function SearchAnnotation(cm, query, caseFold, options) {\n    this.cm = cm;\n    this.options = options;\n    var annotateOptions = {listenForChanges: false};\n    for (var prop in options) annotateOptions[prop] = options[prop];\n    if (!annotateOptions.className) annotateOptions.className = \"CodeMirror-search-match\";\n    this.annotation = cm.annotateScrollbar(annotateOptions);\n    this.query = query;\n    this.caseFold = caseFold;\n    this.gap = {from: cm.firstLine(), to: cm.lastLine() + 1};\n    this.matches = [];\n    this.update = null;\n\n    this.findMatches();\n    this.annotation.update(this.matches);\n\n    var self = this;\n    cm.on(\"change\", this.changeHandler = function(_cm, change) { self.onChange(change); });\n  }\n\n  var MAX_MATCHES = 1000;\n\n  SearchAnnotation.prototype.findMatches = function() {\n    if (!this.gap) return;\n    for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      if (match.from.line >= this.gap.to) break;\n      if (match.to.line >= this.gap.from) this.matches.splice(i--, 1);\n    }\n    var cursor = this.cm.getSearchCursor(this.query, CodeMirror.Pos(this.gap.from, 0), this.caseFold);\n    var maxMatches = this.options && this.options.maxMatches || MAX_MATCHES;\n    while (cursor.findNext()) {\n      var match = {from: cursor.from(), to: cursor.to()};\n      if (match.from.line >= this.gap.to) break;\n      this.matches.splice(i++, 0, match);\n      if (this.matches.length > maxMatches) break;\n    }\n    this.gap = null;\n  };\n\n  function offsetLine(line, changeStart, sizeChange) {\n    if (line <= changeStart) return line;\n    return Math.max(changeStart, line + sizeChange);\n  }\n\n  SearchAnnotation.prototype.onChange = function(change) {\n    var startLine = change.from.line;\n    var endLine = CodeMirror.changeEnd(change).line;\n    var sizeChange = endLine - change.to.line;\n    if (this.gap) {\n      this.gap.from = Math.min(offsetLine(this.gap.from, startLine, sizeChange), change.from.line);\n      this.gap.to = Math.max(offsetLine(this.gap.to, startLine, sizeChange), change.from.line);\n    } else {\n      this.gap = {from: change.from.line, to: endLine + 1};\n    }\n\n    if (sizeChange) for (var i = 0; i < this.matches.length; i++) {\n      var match = this.matches[i];\n      var newFrom = offsetLine(match.from.line, startLine, sizeChange);\n      if (newFrom != match.from.line) match.from = CodeMirror.Pos(newFrom, match.from.ch);\n      var newTo = offsetLine(match.to.line, startLine, sizeChange);\n      if (newTo != match.to.line) match.to = CodeMirror.Pos(newTo, match.to.ch);\n    }\n    clearTimeout(this.update);\n    var self = this;\n    this.update = setTimeout(function() { self.updateAfterChange(); }, 250);\n  };\n\n  SearchAnnotation.prototype.updateAfterChange = function() {\n    this.findMatches();\n    this.annotation.update(this.matches);\n  };\n\n  SearchAnnotation.prototype.clear = function() {\n    this.cm.off(\"change\", this.changeHandler);\n    this.annotation.clear();\n  };\n});\n"]}