{"version":3,"sources":["addon/search/searchcursor.js"],"names":["define","CodeMirror","SearchCursor","doc","query","pos","caseFold","this","atOccurrence","clipPos","Pos","from","to","global","RegExp","source","ignoreCase","matches","reverse","lastIndex","match","start","line","getLine","slice","ch","cutOff","newMatch","exec","index","length","matchLen","undefined","origQuery","toLowerCase","fold","str","target","split","orig","lastIndexOf","adjustPos","indexOf","origTarget","last","firstLine","ln","i","cut","lastLine","folded","pos1","Math","min","len1","prototype","findNext","find","findPrevious","savePosAndFail","self","maxLine","lineCount","replace","newText","origin","lines","splitLines","replaceRange","defineExtension","defineDocExtension","ranges","cur","getSearchCursor","getCursor","cmpPos","push","anchor","head","setSelections"],"mappings":"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","file":"../../../addon/search/searchcursor.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  \"use strict\";\n  var Pos = CodeMirror.Pos;\n\n  function SearchCursor(doc, query, pos, caseFold) {\n    this.atOccurrence = false; this.doc = doc;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") { // Regexp match\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? \"ig\" : \"g\");\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          query.lastIndex = 0;\n          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\n          for (;;) {\n            query.lastIndex = cutOff;\n            var newMatch = query.exec(line);\n            if (!newMatch) break;\n            match = newMatch;\n            start = match.index;\n            cutOff = match.index + (match[0].length || 1);\n            if (cutOff == line.length) break;\n          }\n          var matchLen = (match && match[0].length) || 0;\n          if (!matchLen) {\n            if (start == 0 && line.length == 0) {match = undefined;}\n            else if (start != doc.getLine(pos.line).length) {\n              matchLen++;\n            }\n          }\n        } else {\n          query.lastIndex = pos.ch;\n          var line = doc.getLine(pos.line), match = query.exec(line);\n          var matchLen = (match && match[0].length) || 0;\n          var start = match && match.index;\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\n        }\n        if (match && matchLen)\n          return {from: Pos(pos.line, start),\n                  to: Pos(pos.line, start + matchLen),\n                  match: match};\n      };\n    } else { // String query\n      var origQuery = query;\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1) {\n        if (!query.length) {\n          // Empty string would match anything and never progress, so\n          // we define it to match nothing instead.\n          this.matches = function() {};\n        } else {\n          this.matches = function(reverse, pos) {\n            if (reverse) {\n              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\n              var match = line.lastIndexOf(query);\n              if (match > -1) {\n                match = adjustPos(orig, line, match);\n                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n              }\n             } else {\n               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\n               var match = line.indexOf(query);\n               if (match > -1) {\n                 match = adjustPos(orig, line, match) + pos.ch;\n                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\n               }\n            }\n          };\n        }\n      } else {\n        var origTarget = origQuery.split(\"\\n\");\n        this.matches = function(reverse, pos) {\n          var last = target.length - 1;\n          if (reverse) {\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\n            var to = Pos(pos.line, origTarget[last].length);\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            return {from: Pos(ln, cut), to: to};\n          } else {\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\n            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\n            if (fold(line.slice(cut)) != target[0]) return;\n            var from = Pos(pos.line, cut);\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\n              if (target[i] != fold(doc.getLine(ln))) return;\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\n            return {from: from, to: Pos(ln, origTarget[last].length)};\n          }\n        };\n      }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = Pos(line, 0);\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\n        }\n        else {\n          var maxLine = this.doc.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = Pos(pos.line + 1, 0);\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return;\n      var lines = CodeMirror.splitLines(newText);\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\n    }\n  };\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos) {\n    if (orig.length == folded.length) return pos;\n    for (var pos1 = Math.min(pos, orig.length);;) {\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\n      if (len1 < pos) ++pos1;\n      else if (len1 > pos) --pos1;\n      else return pos1;\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold);\n  });\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = [];\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold);\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break;\n      ranges.push({anchor: cur.from(), head: cur.to()});\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0);\n  });\n});\n"]}