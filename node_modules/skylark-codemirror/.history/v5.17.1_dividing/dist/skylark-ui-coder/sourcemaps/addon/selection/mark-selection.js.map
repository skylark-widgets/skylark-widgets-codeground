{"version":3,"sources":["addon/selection/mark-selection.js"],"names":["define","CodeMirror","onCursorActivity","cm","operation","update","onChange","state","markedSelection","length","clear","coverRange","from","to","addAt","cmp","array","cls","markedSelectionStyle","line","start","Pos","endLine","CHUNK_SIZE","atEnd","end","mark","markText","className","push","splice","i","reset","ranges","listSelections","somethingSelected","getCursor","coverStart","find","coverEnd","shift","pop","defineOption","val","old","prev","Init","on","off","cmpPos"],"mappings":"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","file":"../../../addon/selection/mark-selection.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Because sometimes you need to mark the selected *text*.\n//\n// Adds an option 'styleSelectedText' which, when enabled, gives\n// selected text the CSS class given as option value, or\n// \"CodeMirror-selectedtext\" when the value is not a string.\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineOption(\"styleSelectedText\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      cm.state.markedSelection = [];\n      cm.state.markedSelectionStyle = typeof val == \"string\" ? val : \"CodeMirror-selectedtext\";\n      reset(cm);\n      cm.on(\"cursorActivity\", onCursorActivity);\n      cm.on(\"change\", onChange);\n    } else if (!val && prev) {\n      cm.off(\"cursorActivity\", onCursorActivity);\n      cm.off(\"change\", onChange);\n      clear(cm);\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\n    }\n  });\n\n  function onCursorActivity(cm) {\n    cm.operation(function() { update(cm); });\n  }\n\n  function onChange(cm) {\n    if (cm.state.markedSelection.length)\n      cm.operation(function() { clear(cm); });\n  }\n\n  var CHUNK_SIZE = 8;\n  var Pos = CodeMirror.Pos;\n  var cmp = CodeMirror.cmpPos;\n\n  function coverRange(cm, from, to, addAt) {\n    if (cmp(from, to) == 0) return;\n    var array = cm.state.markedSelection;\n    var cls = cm.state.markedSelectionStyle;\n    for (var line = from.line;;) {\n      var start = line == from.line ? from : Pos(line, 0);\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\n      var end = atEnd ? to : Pos(endLine, 0);\n      var mark = cm.markText(start, end, {className: cls});\n      if (addAt == null) array.push(mark);\n      else array.splice(addAt++, 0, mark);\n      if (atEnd) break;\n      line = endLine;\n    }\n  }\n\n  function clear(cm) {\n    var array = cm.state.markedSelection;\n    for (var i = 0; i < array.length; ++i) array[i].clear();\n    array.length = 0;\n  }\n\n  function reset(cm) {\n    clear(cm);\n    var ranges = cm.listSelections();\n    for (var i = 0; i < ranges.length; i++)\n      coverRange(cm, ranges[i].from(), ranges[i].to());\n  }\n\n  function update(cm) {\n    if (!cm.somethingSelected()) return clear(cm);\n    if (cm.listSelections().length > 1) return reset(cm);\n\n    var from = cm.getCursor(\"start\"), to = cm.getCursor(\"end\");\n\n    var array = cm.state.markedSelection;\n    if (!array.length) return coverRange(cm, from, to);\n\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\n      return reset(cm);\n\n    while (cmp(from, coverStart.from) > 0) {\n      array.shift().clear();\n      coverStart = array[0].find();\n    }\n    if (cmp(from, coverStart.from) < 0) {\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\n        array.shift().clear();\n        coverRange(cm, from, coverStart.to, 0);\n      } else {\n        coverRange(cm, from, coverStart.from, 0);\n      }\n    }\n\n    while (cmp(to, coverEnd.to) < 0) {\n      array.pop().clear();\n      coverEnd = array[array.length - 1].find();\n    }\n    if (cmp(to, coverEnd.to) > 0) {\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\n        array.pop().clear();\n        coverRange(cm, coverEnd.from, to);\n      } else {\n        coverRange(cm, coverEnd.to, to);\n      }\n    }\n  }\n});\n"]}