{"version":3,"sources":["keymap/vim.js"],"names":["define","CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","enterVimMode","cm","setOption","signal","mode","on","onCursorActivity","maybeInitVimState","getInputField","getOnPasteFn","leaveVimMode","off","state","vim","detachVimMap","next","this","keyMap","rmClass","getWrapperElement","attach","attachVimMap","prev","addClass","cmKey","key","vimKey","cmKeyToVimKey","cmd","findKey","charAt","pieces","split","lastPiece","length","hasCharacter","i","piece","modifiers","specialKeys","isUpperCase","toLowerCase","join","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","makeKeyRange","start","size","push","String","fromCharCode","isLine","line","firstLine","lastLine","isLowerCase","k","test","isMatchableSymbol","indexOf","isNumber","numberRegex","isWhiteSpaceString","inArray","val","arr","defineOption","defaultValue","aliases","callback","undefined","Error","options","value","cfg","option","scope","getOption","local","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","createInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","marks","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","vimGlobalState","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","createCircularJumpList","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","optionName","prefixRepeat","motionRepeat","keyBuffer","registerName","clearInputState","reason","Register","text","clear","insertModeChanges","searchQueries","defineRegister","register","registers","validRegisters","unnamedRegister","historyBuffer","iterator","initialPrefix","defineMotion","fn","motions","fillArray","times","defineOperator","operators","defineAction","clipCursorToContent","cur","includeLineBreak","Math","min","max","maxCh","lineLength","ch","copyArgs","args","ret","prop","hasOwnProperty","offsetLine","offsetCh","getOffset","anchor","head","commandMatches","match","partial","full","command","commandMatch","pressed","mapped","slice","prefixLen","pressedPrefix","mappedPrefix","lastChar","exec","repeatFn","repeat","copyCursor","cursorEqual","cur1","cur2","cursorIsBefore","cursorMin","arguments","apply","Array","prototype","call","cursorMax","cursorIsBetween","cur3","cur1before2","cur2before3","lineNum","getLine","trim","s","escapeRegex","extendLineToColumn","column","endCh","spaces","replaceRange","selectBlock","selectionEnd","selections","ranges","listSelections","clipPos","isClipped","curHead","primIndex","getIndex","wasClipped","index","base","baseCh","headCh","dir","newDir","range","setSelections","selectForInsert","height","lineHead","cursor","end","atAnchor","atHead","getSelectedAreaRange","getCurrentSelectedAreaRange","selectionStart","getLastSelectedAreaRange","block","width","anchorMark","find","headMark","setSelection","updateLastSelection","posFromIndex","indexFromPos","setBookmark","expandSelection","tmp","updateCmSelection","cmSel","makeCmSelection","primary","updateFakeCursor","exclusive","headOffset","anchorOffset","top","left","bottom","right","getHead","getSelection","exitVisualMode","moveHead","clipToLine","curStart","curEnd","selection","getRange","lines","pop","expandSelectionToLine","_cm","findFirstNonWhiteSpaceCharacter","firstNonWS","search","expandWordUnderCursor","_forward","noSymbol","idx","wordCharTest","bigWordCharTest","wordStart","recordJumpPosition","oldCur","newCur","add","recordLastCharacterSearch","findSymbol","symb","endLine","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb",")","}","(","{","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findWord","emptyLineIsWord","pos","charTests","from","to","stop","foundWord","moveToWord","words","word","eodCh","shortCircuit","firstWord","lastWord","moveToCharacter","character","charIdxInLine","moveToColumn","updateMark","markName","validMarks","includeChar","lastIndexOf","findParagraph","isEmpty","isBoundary","any","startState","selectCompanionObject","bracketRegexp","[","]","openSym","curChar","offset","scanForBracket","bracketRegex","findBeginningAndEnd","len","chars","firstIndex","SearchState","getSearchState","searchState_","dialog","template","shortText","onClose","openDialog","onKeyDown","onKeyUp","selectValueOnOpen","prompt","splitBySlash","argString","slashes","findUnescapedSlashes","tokens","substring","str","escapeNextChar","c","translateRegex","specials","unescape","out","n","specialComesNext","translateRegexReplace","charUnescapes","unescapeRegexReplace","stream","StringStream","output","eol","peek","matched","matcher","unescapes","parseQuery","query","ignoreCase","smartCase","lastSearchRegister","getRegister","setText","RegExp","regexPart","forceIgnoreCase","flagsPart","regexp","showConfirm","openNotification","duration","alert","makePrompt","prefix","desc","raw","showPrompt","regexEqual","r1","r2","props","updateSearchQuery","rawQuery","highlightSearchMatches","getQuery","setQuery","searchOverlay","source","matchSol","token","sol","skipToEnd","backUp","searchState","overlay","getOverlay","removeOverlay","addOverlay","showMatchesOnScrollbar","getScrollbarAnnotate","setScrollbarAnnotate","setOverlay","findNext","operation","getSearchCursor","found","clearSearchHighlight","isInRange","getUserVisibleLines","scrollInfo","getScrollInfo","occludeToleranceTop","occludeToleranceBottom","coordsChar","bottomY","clientHeight","doReplace","confirm","global","lineStart","lineEnd","searchCursor","replaceWith","replaceAll","done","newText","lastPos","scrollIntoView","close","focus","exMode","onPromptKeyDown","e","_value","e_stop","keyName","savedCallback","exitInsertMode","insertModeChangeRegister","lastChange","selLength","inVisualBlock","changes","InsertModeKey","onChange","onKeyEventTargetKeyDown","repeatLastEdit","repeatOverride","toggleOverwrite","logInsertModeChange","_mapCommand","unshift","mapCommand","extra","executeMacroRegister","exCommandDispatcher","processCommand","imc","handleKey","repeatInsertModeChanges","logKey","pushText","pushInsertModeChanges","logSearchQuery","pushSearchQuery","changeObj","expectCursorActivityForChange","origin","curOp","isVimOp","handleExternalSelection","markText","className","somethingSelected","onKeyFound","lookupKey","repeatForInsert","repeatCommand","isAction","commandDispatcher","processAction","evalInput","repeatInsert","changeObject","cachedInputState","keyHandler","binding","commands","lastSel","j","change","Init","Shift","Ctrl","Alt","Cmd","Mod","Enter","Backspace","Delete","Insert","isWordChar","upperCaseAlphabet","lowerCaseAlphabet","numbers","concat","useNextSlot","pointer","trashMark","buffer","current","curMark","markPos","tail","move","mark","inc","cachedCursor","exitMacroRecordMode","enterMacroRecordMode","lastInsertModeKeyTimer","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","map","lhs","rhs","ctx","unmap","defineEx","func","exCommands","commandMap_","handleMacroRecording","handleEsc","doKeyToKey","handleKeyInsertMode","keysAreChars","matchCommand","thisMatch","window","clearTimeout","setTimeout","here","handleKeyNonInsertMode","keysMatcher","pushRepeatDigit","console","handleEx","input","getRepeat","parseInt","toString","isValidRegister","shiftNumericRegisters_","append","nextMatch","up","element","pushInput","splice","reset","matches","bestMatch","processMotion","processOperator","processOperatorMotion","processSearch","processEx","repeatIsExplicit","recordLastEdit","handleQuery","onPromptClose","scrollTo","originalScrollPos","onPromptKeyUp","parsedQuery","originalQuery","setReversed","promptPrefix","shift","searchPromptDesc","isKeyword","exArgs","newHead","newAnchor","origHead","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","Infinity","lineOffset","abs","chOffset","operatorMoveTo","actionCommand","moveToTopLine","_head","moveToMiddleLine","floor","moveToBottomLine","expandToLine","isReversed","goToMark","moveToOtherHighlightedEnd","jumpToMark","best","isWrongDirection","equal","between","moveByCharacters","moveByLines","moveByDisplayLines","moveByScroll","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","lastCharCoords","goalCoords","resCoords","moveByPage","moveByParagraph","scrollbox","defaultTextHeight","orig","dest","moveByWords","moveTillCharacter","moveToSymbol","retval","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","style","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","textObjectManipulation","mirroredPairs","selfPaired","'","\"","repeatLastCharacterSearch","lastSearch","moveH","finalHead","replacement","replaceSelections","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","newlineAndIndent","delete","indent","startLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","y","replayMacro","overwrite","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineFn","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","tabs","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","selectedText","emptyStrings","undo","redo","setRegister","setMark","replaceTo","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","number","*","/","m","M","#","bracket","section","comment","method","preprocess","reversed","annotate","\\n","\\r","\\t","\\/","\\\\","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","params","parseInput_","commandName","matchCommand_","parseCommandArgs_","toInput","result","eatWhile","eat","parseLineSpec_","numberMatch","delim","argDelimiter","user","mapping","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","setlocal","setglobal","regArgs","regInfo","sort","parseArgs","reverse","eatSpace","opts","unique","decimal","hex","octal","compareFn","a","b","anum","bnum","radix","err","numPart","textPart","textOld","matchedLines","content","nextCommand","substitute","trailing","count","replacePart","startPos","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","detach","fallthrough"],"mappings":"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","file":"../../keymap/vim.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\ndefine([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], function(CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n    // Key to key mapping. This goes first to make it possible to override\n    // existing mappings.\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\n    // Motions\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\n    { keys: '\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\n    { keys: ']\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\n    { keys: '[\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\n    // the next two aren't motions but must come before more general motion declarations\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\n    // Operators\n    { keys: 'd', type: 'operator', operator: 'delete' },\n    { keys: 'y', type: 'operator', operator: 'yank' },\n    { keys: 'c', type: 'operator', operator: 'change' },\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\n    // Operator-Motion dual commands\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\n    // Actions\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\n    // Handle Replace-mode as a special case of insert mode.\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\n    { keys: '<C-r>', type: 'action', action: 'redo' },\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\n    { keys: '\"<character>', type: 'action', action: 'setRegister' },\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\n    // Text object motions\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\n    // Search\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\n    // Ex command\n    { keys: ':', type: 'ex' }\n  ];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [\n    { name: 'colorscheme', shortName: 'colo' },\n    { name: 'map' },\n    { name: 'imap', shortName: 'im' },\n    { name: 'nmap', shortName: 'nm' },\n    { name: 'vmap', shortName: 'vm' },\n    { name: 'unmap' },\n    { name: 'write', shortName: 'w' },\n    { name: 'undo', shortName: 'u' },\n    { name: 'redo', shortName: 'red' },\n    { name: 'set', shortName: 'se' },\n    { name: 'set', shortName: 'se' },\n    { name: 'setlocal', shortName: 'setl' },\n    { name: 'setglobal', shortName: 'setg' },\n    { name: 'sort', shortName: 'sor' },\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\n    { name: 'nohlsearch', shortName: 'noh' },\n    { name: 'yank', shortName: 'y' },\n    { name: 'delmarks', shortName: 'delm' },\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\n    { name: 'global', shortName: 'g' }\n  ];\n\n  var Pos = CodeMirror.Pos;\n\n  var Vim = function() {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!next || next.attach != attachVimMap)\n        leaveVimMode(cm, false);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim)\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n\n      if (!prev || prev.attach != attachVimMap)\n        enterVimMode(cm);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\")\n        cm.setOption(\"keyMap\", \"vim\");\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\")))\n        cm.setOption(\"keyMap\", \"default\");\n    });\n\n    function cmKey(key, cm) {\n      if (!cm) { return undefined; }\n      if (this[key]) { return this[key]; }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\n        else { hasCharacter = true; }\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function() {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\n      return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n    }], bigWordCharTest = [function(ch) {\n      return /\\S/.test(ch);\n    }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return (/^[a-z]$/).test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return (/^[A-Z]$/).test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return (/^\\s*$/).test(k);\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) { type = 'string'; }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        throw Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          throw Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {value: value};\n        }\n      }\n    }\n\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        throw Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\n        return (local || (scope !== 'local') && option || {}).value;\n      }\n    }\n\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n\n    var createCircularJumpList = function() {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark &&\n                (newCur = mark.find()) &&\n                !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined, //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function(c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function(cm, registerName) {\n        var register =\n            vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog(\n                '(recording)['+registerName+']', null, {bottom:true});\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState,\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController({}),\n        // ex Command history buffer\n        exCommandHistoryController : new HistoryController({})\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n\n    var lastInsertModeKeyTimer;\n    var vimApi= {\n      buildKeyMap: function() {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function() {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n\n      // Testing hook.\n      getVimGlobalState_: function() {\n        return vimGlobalState;\n      },\n\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n\n      suppressErrorLogging: false,\n\n      InsertModeKey: InsertModeKey,\n      map: function(lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function(lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function(name, prefix, func){\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"'+prefix+'\" is not a prefix of \"'+name+'\", command not registered');\n        }\n        exCommands[name]=func;\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function(cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = (/<\\w+-.+?>|<\\w+>|./).exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n\n        function handleKeyInsertMode() {\n          if (handleEsc()) { return true; }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') { match = thisMatch; }\n          }\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n            lastInsertModeKeyTimer = window.setTimeout(\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\n              getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\n          if (keysAreChars) {\n            var here = cm.getCursor();\n            cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) { return true; };\n\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) { return true; }\n\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) { clearInputState(cm); return false; }\n          var context = vim.visualMode ? 'visual' :\n                                         'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') { clearInputState(cm); return false; }\n          else if (match.type == 'partial') { return true; }\n\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n\n        var command;\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\n        else { command = handleKeyNonInsertMode(); }\n        if (command === false) {\n          return undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function() {};\n        } else {\n          return function() {\n            return cm.operation(function() {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function(cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n\n      defineRegister: defineRegister,\n\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function(n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function() {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function(text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function(text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function(changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function(query) {\n        this.searchQueries.push(query);\n      },\n      clear: function() {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function() {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers[name];\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function(registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(0) == '\\n') {\n          text = text.slice(1) + '\\n';\n        }\n        if (linewise && text.charAt(text.length - 1) !== '\\n'){\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ?\n            this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function(name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function(name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function() {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n        this.historyBuffer = [];\n        this.iterator = 0;\n        this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0 ) return input;\n      },\n      pushInput: function(input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function() {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function(keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {type: 'none'};\n        } else if (!matches.full && matches.partial) {\n          return {type: 'partial'};\n        }\n\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          inputState.selectedCharacter = lastChar(keys);\n        }\n        return {type: 'full', command: bestMatch};\n      },\n      processCommand: function(cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function(cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = { linewise: true };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function(cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function(cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function(cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = (forward) ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e), up;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query,\n                true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && query == '')) {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                  onClose: onPromptClose,\n                  prefix: promptPrefix,\n                  desc: searchPromptDesc,\n                  onKeyUp: onPromptKeyUp,\n                  onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\n                true /** forward */, false /** bigWord */,\n                true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */,\n                  true /** forward */, false /** bigWord */,\n                  false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\n                word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n                query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function(cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e), up;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\n              (keyName == 'Backspace' && input == '')) {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\n              vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\'<,\\'>',\n                onKeyDown: onPromptKeyDown});\n          } else {\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\n                onKeyDown: onPromptKeyDown});\n          }\n        }\n      },\n      evalInput: function(cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat ||\n            (!motionArgs.explicitRepeat && repeat === 0)) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n              inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<',\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\n                    : newHead);\n            updateMark(cm, vim, '>',\n                cursorIsBefore(newAnchor, newHead) ? newHead\n                    : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' :\n                   linewise ? 'line' :\n                   'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function(vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function(cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function(cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function(_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function(cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = (state.isReversed()) ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function(cm, _head, motionArgs, vim) {\n        var mark = vim.marks[motionArgs.selectedCharacter];\n        if (mark) {\n          var pos = mark.find();\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\n          ];\n        } else {\n          return ([vim.sel.head, vim.sel.anchor]);\n        }\n      },\n      jumpToMark: function(cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = (motionArgs.forward) ?\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\n              continue;\n            }\n\n            var equal = cursorEqual(cursor, best);\n            var between = (motionArgs.forward) ?\n              cursorIsBetween(cursor, mark, best) :\n              cursorIsBetween(best, mark, cursor);\n\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function(_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first){\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        }else if (line > last && cur.line == last){\n            return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar){\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function(cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\n      },\n      moveByParagraph: function(cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function(cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function(cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function(cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function(cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward,\n            motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function(cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head,'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function(cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end=cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end,'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function(cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        do {\n          symbol = lineText.charAt(ch++);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        } while (symbol);\n        if (symbol) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function(_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum,\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {'(': ')', ')': '(',\n                             '{': '}', '}': '{',\n                             '[': ']', ']': '['};\n        var selfPaired = {'\\'': true, '\"': true};\n\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\n                                                     false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) { vim.visualLine = true; }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) { operatorArgs.linewise = true; }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = (/\\s+$/).exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, - match[0].length);\n              text = text.slice(0, - match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'change', text,\n            args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function(cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n              head = ranges[0].head;\n          if (args.linewise &&\n              head.line != cm.firstLine() &&\n              anchor.line == cm.lastLine() &&\n              anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'delete', text,\n            args.linewise, vim.visualBlock);\n        return clipCursorToContent(cm, finalHead);\n      },\n      indent: function(cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ?\n          ranges[ranges.length - 1].anchor.line :\n          ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = (vim.visualMode) ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() :\n                  character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor){\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise){\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function(cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\n          : oldAnchor;\n        vimGlobalState.registerController.pushText(\n            args.registerName, 'yank',\n            text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n\n    var actions = {\n      jumpListWalk: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function(cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\n             cursor.line = Math.ceil(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(null, cursorCoords.top);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n             cursor.line = Math.floor(cursor.line);\n             cm.setCursor(cursor);\n             cursorCoords = cm.charCoords(cursor, 'local');\n             cm.scrollTo(\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n             // Cursor stays within bounds.  Just reposition the scroll window.\n             cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function(cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center': y = y - (height / 2) + lineHeight;\n            break;\n          case 'bottom': y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function(cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while(repeat--){\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function(cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      },\n      toggleOverwrite: function(cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n      },\n      enterInsertMode: function(cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) { return; }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(\n                Math.min(sel.head.line, sel.anchor.line),\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode){\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"replace\"});\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"insert\"});\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function(cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\n              true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise ||\n            vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\", subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"});\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function(cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' :\n                     vim.visualBlock ? 'blockwise' : ''});\n        }\n      },\n      joinLines: function(cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\n                                               Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1,\n                        lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = (actionArgs.after) ? insertAt.line :\n              insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\n              CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n      },\n      paste: function(cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(\n            actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function(str) {\n            var tabs = (str.split(\"\\t\").length - 1);\n            var spaces = (str.split(\" \").length - 1);\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function(wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            }\n            else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            }\n            else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if(vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = (text[i] == '') ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if(lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch=0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line+i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n',  Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(\n                cur.line,\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function(cm, actionArgs) {\n        cm.operation(function() {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function(cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function(_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function(cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function(cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo=line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith=='\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\")+1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\n                         selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function(cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /-?\\d+/g;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        var token;\n        while ((match = re.exec(lineStr)) !== null) {\n          token = match[0];\n          start = match.index;\n          end = start + token.length;\n          if (cur.ch < end)break;\n        }\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\n        if (token) {\n          var increment = actionArgs.increase ? 1 : -1;\n          var number = parseInt(token) + (increment * actionArgs.repeat);\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          numberStr = number.toString();\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function(cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) { return; }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      exitInsertMode: exitInsertMode\n    };\n\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match, partial = [], full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' ||\n            command.context && command.context != context ||\n            inputState.operator && command.type == 'action' ||\n            !(match = commandMatch(keys, command.keys))) { continue; }\n        if (match == 'partial') { partial.push(command); }\n        if (match == 'full') { full.push(command); }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' :\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[\\w\\-]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1){\n        switch(selectedCharacter){\n          case '<CR>':\n            selectedCharacter='\\n';\n            break;\n          case '<Space>':\n            selectedCharacter=' ';\n            break;\n          default:\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function() {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column-endCh+1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [], ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch, headCh = head.ch;\n\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) { headCh--; }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) { headCh++; }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\n        selections.push(range);\n      }\n      primIndex = head.line == lastLine ? selections.length - 1 : 0;\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({anchor: lineHead, head: lineHead});\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function() {\n        var selections = cm.listSelections();\n        var start =  selections[0];\n        var end = selections[selections.length-1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function() {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {anchor: anchor, head: head};\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n      // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\n                           'headMark': cm.setBookmark(head),\n                           'anchor': copyCursor(anchor),\n                           'head': copyCursor(head),\n                           'visualMode': vim.visualMode,\n                           'visualLine': vim.visualLine,\n                           'visualBlock': vim.visualBlock};\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode ||\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{anchor: anchor, head: head}],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n            left = Math.min(anchor.ch, head.ch),\n            bottom = Math.max(anchor.line, head.line),\n            right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) { return null; }\n      }\n\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n\n      var end = idx, start = idx;\n      while (test(line.charAt(end)) && end < line.length) { end++; }\n      while (test(line.charAt(start)) && start >= 0) { start--; }\n      start++;\n\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) { end++; }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\n          if (!start) { start = wordStart; }\n        }\n      }\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\n    }\n\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n\n    function recordLastCharacterSearch(increment, args) {\n        vimGlobalState.lastCharacterSearch.increment = increment;\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n\n    var symbolToMode = {\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\n        '[': 'section', ']': 'section',\n        '*': 'comment', '/': 'comment',\n        'm': 'method', 'M': 'method',\n        '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function(state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1)return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function(state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function(state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function(state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function(state) {\n          state.symb = (state.symb === 'm' ? '{' : '}');\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function(state) {\n          if (state.nextCh === state.symb)return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function(state) {\n          state.index = 0;\n        },\n        isComplete: function(state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0)return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode)return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) { init(state); }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /**\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\n\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = (forward) ? 0 : line.length;\n      }\n\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return { from: 0, to: 0, line: lineNum };\n        }\n        var stop = (dir > 0) ? line.length : -1;\n        var wordStart = stop, wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line &&\n                  wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = (dir > 0) ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\n              : {line: 0, from: 0, to: 0});\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i ++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start, end, i = line;\n      function isEmpty(i) { return !cm.getLine(i); }\n      function isBoundary(i, dir, any) {\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) { repeat--; }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) { startState = true; }\n      else { inclusive = false; }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) { break; }\n        }\n      }\n      start = new Pos(i, 0);\n      return { start: start, end: end };\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head, start, end;\n\n      var bracketRegexp = ({\n        '(': /[()]/, ')': /[()]/,\n        '[': /[[\\]]/, ']': /[[\\]]/,\n        '{': /[{}]/, '}': /[{}]/})[symb];\n      var openSym = ({\n        '(': '(', ')': '(',\n        '[': '[', ']': '[',\n        '{': '{', '}': '{'})[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, null, {'bracketRegex': bracketRegexp});\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, null, {'bracketRegex': bracketRegexp});\n\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      start = start.pos;\n      end = end.pos;\n\n      if ((start.line == end.line && start.ch > end.ch)\n          || (start.line > end.line)) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n\n      return { start: start, end: end };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return { start: cur, end: cur };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start; ++end;\n      }\n\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function() {\n        return vimGlobalState.query;\n      },\n      setQuery: function(query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function() {\n        return this.searchOverlay;\n      },\n      setOverlay: function(overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function() {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function(reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function() {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function(annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\n            selectValueOnOpen: false});\n      }\n      else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      var slashes = findUnescapedSlashes(argString) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number')\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\n      }\n      return tokens;\n    }\n\n    function findUnescapedSlashes(str) {\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == '/') {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && (c == '\\\\');\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        var specialComesNext = (n && specials.indexOf(n) != -1);\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {'\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i+1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c+n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if ((isNumber(n) || n === '$')) {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {'\\\\/': '/', '\\\\\\\\': '\\\\', '\\\\n': '\\n', '\\\\r': '\\r', '\\\\t': '\\t'};\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) { return query; }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\n      }\n      var regexp = new RegExp(regexPart,\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>',\n                            {bottom: true, duration: 5000});\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' +\n          (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc)\n        raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\n          for (var i = 0; i < props.length; i++) {\n              var prop = props[i];\n              if (r1[prop] !== r2[prop]) {\n                  return false;\n              }\n          }\n          return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function(stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) { repeat = 1; }\n      return cm.operation(function() {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query,\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return (pos >= start && pos <= end);\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\n      return {top: from.line, bottom: to.line};\n    }\n\n    var ExCommandDispatcher = function() {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function(cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function(cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch(e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function(cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n\n        return result;\n      },\n      parseLineSpec_: function(cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return cm.getCursor().line;\n          case '$':\n            return cm.lastLine();\n          case '\\'':\n            var mark = cm.state.vim.marks[inputStream.next()];\n            if (mark && mark.find()) {\n              return mark.find().line;\n            }\n            throw new Error('Mark not set');\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseCommandArgs_: function(inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function(commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function() {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function(lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: { input: rhs.substring(1) },\n              user: true};\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs,\n              user: true\n            };\n            if (ctx) { mapping.context = ctx; }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function(lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys\n                && defaultKeymap[i].context === ctx\n                && defaultKeymap[i].user) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n\n    var exCommands = {\n      colorscheme: function(cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\n      unmap: function(cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function(cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n            type: 'motion',\n            motion: 'moveToLineOrEdgeOfDocument',\n            motionArgs: { forward: false, explicitRepeat: true,\n              linewise: true },\n            repeatOverride: params.line+1});\n      },\n      set: function(cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          setOption(optionName, value, cm, setCfg);\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'local'};\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {scope: 'global'};\n        this.set(cm, params);\n      },\n      registers: function(cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function(cm, params) {\n        var reverse, ignoreCase, unique, number;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) { reverse = true; }\n            if (args.eol()) { return; }\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\n            var opts = args.match(/[a-z]+/);\n            if (opts) {\n              opts = opts[0];\n              ignoreCase = opts.indexOf('i') != -1;\n              unique = opts.indexOf('u') != -1;\n              var decimal = opts.indexOf('d') != -1 && 1;\n              var hex = opts.indexOf('x') != -1 && 1;\n              var octal = opts.indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (args.match(/\\/.*\\//)) { return 'patterns not supported'; }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) { return; }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = (number == 'decimal') ? /(-?)([\\d]+)/ :\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\n           (number == 'octal') ? /([0-7]+)/ : null;\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\n        var numPart = [], textPart = [];\n        if (number) {\n          for (var i = 0; i < text.length; i++) {\n            if (numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) { return a < b ? -1 : 1; }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        numPart.sort(compareFn);\n        textPart.sort(compareFn);\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) { // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function(cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString, cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n             true /** smartCase */);\n          } catch (e) {\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\n           return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [], content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i+1);\n            content+= cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function() {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function(cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\n              'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySlash(argString) : [];\n        var regexPart, replacePart = '', trailing, flagsPart, count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' +\n                ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\n              true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function(cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function(cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText(\n          '0', 'yank', lineText, true, true);\n      },\n      delmarks: function(cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\n        replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function() {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while(searchCursor.findNext() &&\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) { close(); }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) { callback(); }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace(); next(); break;\n          case 'N':\n            next(); break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n            // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) { stop(close); }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) { callback(); };\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n             i++;\n          } else {\n             i+= selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\n            true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"normal\"});\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {keys: keys, type: type};\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra)\n        command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = (/<\\w+-.+?>|<\\w+>|./).exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\n                changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      };\n      macroModeState.isPlaying = false;\n    }\n\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) { return; }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(_cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while(changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste'\n              || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            lastChange.changes.push(text);\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) { return; }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.changes = [];\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {mode: \"visual\"});\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) { return; }\n      function onKeyFound() {\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    };\n\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});\n"]}