{"version":3,"sources":["mode/clojure/clojure.js"],"names":["define","CodeMirror","defineMode","options","makeKeywords","str","obj","words","split","i","length","stateStack","indent","type","prev","this","pushStack","state","indentStack","popStack","isNumber","ch","stream","eat","eatWhile","tests","hex","digit","test","peek","sign","next","exponent","eatCharacter","first","match","BUILTIN","COMMENT","STRING","CHARACTER","ATOM","NUMBER","BRACKET","KEYWORD","VAR","INDENT_WORD_SKIP","indentUnit","NORMAL_INDENT_UNIT","atoms","keywords","builtins","indentKeys","digit_or_colon","keyword_char","symbol","block_indent","startState","indentation","mode","token","sol","eatSpace","returnType","escaped","skipToEnd","letter","keyWord","indentTemp","column","propertyIsEnumerable","eol","current","backUp","closeBrackets","pairs","lineComment","defineMIME"],"mappings":"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","file":"../../../mode/clojure/clojure.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Author: Hans Engel\n * Branched from CodeMirror's Scheme mode (by Koh Zi Han, based on implementation by Koh Zi Chun)\n */\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"clojure\", function (options) {\n    var BUILTIN = \"builtin\", COMMENT = \"comment\", STRING = \"string\", CHARACTER = \"string-2\",\n        ATOM = \"atom\", NUMBER = \"number\", BRACKET = \"bracket\", KEYWORD = \"keyword\", VAR = \"variable\";\n    var INDENT_WORD_SKIP = options.indentUnit || 2;\n    var NORMAL_INDENT_UNIT = options.indentUnit || 2;\n\n    function makeKeywords(str) {\n        var obj = {}, words = str.split(\" \");\n        for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n        return obj;\n    }\n\n    var atoms = makeKeywords(\"true false nil\");\n\n    var keywords = makeKeywords(\n      \"defn defn- def def- defonce defmulti defmethod defmacro defstruct deftype defprotocol defrecord defproject deftest \" +\n      \"slice defalias defhinted defmacro- defn-memo defnk defnk defonce- defunbound defunbound- defvar defvar- let letfn \" +\n      \"do case cond condp for loop recur when when-not when-let when-first if if-let if-not . .. -> ->> doto and or dosync \" +\n      \"doseq dotimes dorun doall load import unimport ns in-ns refer try catch finally throw with-open with-local-vars \" +\n      \"binding gen-class gen-and-load-class gen-and-save-class handler-case handle\");\n\n    var builtins = makeKeywords(\n        \"* *' *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* *command-line-args* *compile-files* \" +\n        \"*compile-path* *compiler-options* *data-readers* *e *err* *file* *flush-on-newline* *fn-loader* *in* \" +\n        \"*math-context* *ns* *out* *print-dup* *print-length* *print-level* *print-meta* *print-readably* *read-eval* \" +\n        \"*source-path* *unchecked-math* *use-context-classloader* *verbose-defrecords* *warn-on-reflection* + +' - -' -> \" +\n        \"->> ->ArrayChunk ->Vec ->VecNode ->VecSeq -cache-protocol-fn -reset-methods .. / < <= = == > >= EMPTY-NODE accessor \" +\n        \"aclone add-classpath add-watch agent agent-error agent-errors aget alength alias all-ns alter alter-meta! \" +\n        \"alter-var-root amap ancestors and apply areduce array-map aset aset-boolean aset-byte aset-char aset-double \" +\n        \"aset-float aset-int aset-long aset-short assert assoc assoc! assoc-in associative? atom await await-for await1 \" +\n        \"bases bean bigdec bigint biginteger binding bit-and bit-and-not bit-clear bit-flip bit-not bit-or bit-set \" +\n        \"bit-shift-left bit-shift-right bit-test bit-xor boolean boolean-array booleans bound-fn bound-fn* bound? butlast \" +\n        \"byte byte-array bytes case cat cast char char-array char-escape-string char-name-string char? chars chunk chunk-append \" +\n        \"chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? class class? clear-agent-errors \" +\n        \"clojure-version coll? comment commute comp comparator compare compare-and-set! compile complement completing concat cond condp \" +\n        \"conj conj! cons constantly construct-proxy contains? count counted? create-ns create-struct cycle dec dec' decimal? \" +\n        \"declare dedupe default-data-readers definline definterface defmacro defmethod defmulti defn defn- defonce defprotocol \" +\n        \"defrecord defstruct deftype delay delay? deliver denominator deref derive descendants destructure disj disj! dissoc \" +\n        \"dissoc! distinct distinct? doall dorun doseq dosync dotimes doto double double-array doubles drop drop-last \" +\n        \"drop-while eduction empty empty? ensure enumeration-seq error-handler error-mode eval even? every-pred every? ex-data ex-info \" +\n        \"extend extend-protocol extend-type extenders extends? false? ffirst file-seq filter filterv find find-keyword \" +\n        \"find-ns find-protocol-impl find-protocol-method find-var first flatten float float-array float? floats flush fn fn? \" +\n        \"fnext fnil for force format frequencies future future-call future-cancel future-cancelled? future-done? future? \" +\n        \"gen-class gen-interface gensym get get-in get-method get-proxy-class get-thread-bindings get-validator group-by hash \" +\n        \"hash-combine hash-map hash-set identical? identity if-let if-not ifn? import in-ns inc inc' init-proxy instance? \" +\n        \"int int-array integer? interleave intern interpose into into-array ints io! isa? iterate iterator-seq juxt keep \" +\n        \"keep-indexed key keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list list* list? load load-file \" +\n        \"load-reader load-string loaded-libs locking long long-array longs loop macroexpand macroexpand-1 make-array \" +\n        \"make-hierarchy map map-indexed map? mapcat mapv max max-key memfn memoize merge merge-with meta method-sig methods \" +\n        \"min min-key mod munge name namespace namespace-munge neg? newline next nfirst nil? nnext not not-any? not-empty \" +\n        \"not-every? not= ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ns-refers ns-resolve ns-unalias \" +\n        \"ns-unmap nth nthnext nthrest num number? numerator object-array odd? or parents partial partition partition-all \" +\n        \"partition-by pcalls peek persistent! pmap pop pop! pop-thread-bindings pos? pr pr-str prefer-method prefers \" +\n        \"primitives-classnames print print-ctor print-dup print-method print-simple print-str printf println println-str \" +\n        \"prn prn-str promise proxy proxy-call-with-super proxy-mappings proxy-name proxy-super push-thread-bindings pvalues \" +\n        \"quot rand rand-int rand-nth random-sample range ratio? rational? rationalize re-find re-groups re-matcher re-matches re-pattern \" +\n        \"re-seq read read-line read-string realized? reduce reduce-kv reductions ref ref-history-count ref-max-history \" +\n        \"ref-min-history ref-set refer refer-clojure reify release-pending-sends rem remove remove-all-methods \" +\n        \"remove-method remove-ns remove-watch repeat repeatedly replace replicate require reset! reset-meta! resolve rest \" +\n        \"restart-agent resultset-seq reverse reversible? rseq rsubseq satisfies? second select-keys send send-off seq seq? \" +\n        \"seque sequence sequential? set set-error-handler! set-error-mode! set-validator! set? short short-array shorts \" +\n        \"shuffle shutdown-agents slurp some some-fn sort sort-by sorted-map sorted-map-by sorted-set sorted-set-by sorted? \" +\n        \"special-symbol? spit split-at split-with str string? struct struct-map subs subseq subvec supers swap! symbol \" +\n        \"symbol? sync take take-last take-nth take-while test the-ns thread-bound? time to-array to-array-2d trampoline transduce \" +\n        \"transient tree-seq true? type unchecked-add unchecked-add-int unchecked-byte unchecked-char unchecked-dec \" +\n        \"unchecked-dec-int unchecked-divide-int unchecked-double unchecked-float unchecked-inc unchecked-inc-int \" +\n        \"unchecked-int unchecked-long unchecked-multiply unchecked-multiply-int unchecked-negate unchecked-negate-int \"+\n        \"unchecked-remainder-int unchecked-short unchecked-subtract unchecked-subtract-int underive unquote \" +\n        \"unquote-splicing update update-in update-proxy use val vals var-get var-set var? vary-meta vec vector vector-of \" +\n        \"vector? volatile! volatile? vreset! vswap! when when-first when-let when-not while with-bindings with-bindings* with-in-str with-loading-context \" +\n        \"with-local-vars with-meta with-open with-out-str with-precision with-redefs with-redefs-fn xml-seq zero? zipmap \" +\n        \"*default-data-reader-fn* as-> cond-> cond->> reduced reduced? send-via set-agent-send-executor! \" +\n        \"set-agent-send-off-executor! some-> some->>\");\n\n    var indentKeys = makeKeywords(\n        // Built-ins\n        \"ns fn def defn defmethod bound-fn if if-not case condp when while when-not when-first do future comment doto \" +\n        \"locking proxy with-open with-precision reify deftype defrecord defprotocol extend extend-protocol extend-type \" +\n        \"try catch \" +\n\n        // Binding forms\n        \"let letfn binding loop for doseq dotimes when-let if-let \" +\n\n        // Data structures\n        \"defstruct struct-map assoc \" +\n\n        // clojure.test\n        \"testing deftest \" +\n\n        // contrib\n        \"handler-case handle dotrace deftrace\");\n\n    var tests = {\n        digit: /\\d/,\n        digit_or_colon: /[\\d:]/,\n        hex: /[0-9a-f]/i,\n        sign: /[+-]/,\n        exponent: /e/i,\n        keyword_char: /[^\\s\\(\\[\\;\\)\\]]/,\n        symbol: /[\\w*+!\\-\\._?:<>\\/\\xa1-\\uffff]/,\n        block_indent: /^(?:def|with)[^\\/]+$|\\/(?:def|with)/\n    };\n\n    function stateStack(indent, type, prev) { // represents a state stack object\n        this.indent = indent;\n        this.type = type;\n        this.prev = prev;\n    }\n\n    function pushStack(state, indent, type) {\n        state.indentStack = new stateStack(indent, type, state.indentStack);\n    }\n\n    function popStack(state) {\n        state.indentStack = state.indentStack.prev;\n    }\n\n    function isNumber(ch, stream){\n        // hex\n        if ( ch === '0' && stream.eat(/x/i) ) {\n            stream.eatWhile(tests.hex);\n            return true;\n        }\n\n        // leading sign\n        if ( ( ch == '+' || ch == '-' ) && ( tests.digit.test(stream.peek()) ) ) {\n          stream.eat(tests.sign);\n          ch = stream.next();\n        }\n\n        if ( tests.digit.test(ch) ) {\n            stream.eat(ch);\n            stream.eatWhile(tests.digit);\n\n            if ( '.' == stream.peek() ) {\n                stream.eat('.');\n                stream.eatWhile(tests.digit);\n            } else if ('/' == stream.peek() ) {\n                stream.eat('/');\n                stream.eatWhile(tests.digit);\n            }\n\n            if ( stream.eat(tests.exponent) ) {\n                stream.eat(tests.sign);\n                stream.eatWhile(tests.digit);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // Eat character that starts after backslash \\\n    function eatCharacter(stream) {\n        var first = stream.next();\n        // Read special literals: backspace, newline, space, return.\n        // Just read all lowercase letters.\n        if (first && first.match(/[a-z]/) && stream.match(/[a-z]+/, true)) {\n            return;\n        }\n        // Read unicode character: \\u1000 \\uA0a1\n        if (first === \"u\") {\n            stream.match(/[0-9a-z]{4}/i, true);\n        }\n    }\n\n    return {\n        startState: function () {\n            return {\n                indentStack: null,\n                indentation: 0,\n                mode: false\n            };\n        },\n\n        token: function (stream, state) {\n            if (state.indentStack == null && stream.sol()) {\n                // update indentation, but only if indentStack is empty\n                state.indentation = stream.indentation();\n            }\n\n            // skip spaces\n            if (state.mode != \"string\" && stream.eatSpace()) {\n                return null;\n            }\n            var returnType = null;\n\n            switch(state.mode){\n                case \"string\": // multi-line string parsing mode\n                    var next, escaped = false;\n                    while ((next = stream.next()) != null) {\n                        if (next == \"\\\"\" && !escaped) {\n\n                            state.mode = false;\n                            break;\n                        }\n                        escaped = !escaped && next == \"\\\\\";\n                    }\n                    returnType = STRING; // continue on in string mode\n                    break;\n                default: // default parsing mode\n                    var ch = stream.next();\n\n                    if (ch == \"\\\"\") {\n                        state.mode = \"string\";\n                        returnType = STRING;\n                    } else if (ch == \"\\\\\") {\n                        eatCharacter(stream);\n                        returnType = CHARACTER;\n                    } else if (ch == \"'\" && !( tests.digit_or_colon.test(stream.peek()) )) {\n                        returnType = ATOM;\n                    } else if (ch == \";\") { // comment\n                        stream.skipToEnd(); // rest of the line is a comment\n                        returnType = COMMENT;\n                    } else if (isNumber(ch,stream)){\n                        returnType = NUMBER;\n                    } else if (ch == \"(\" || ch == \"[\" || ch == \"{\" ) {\n                        var keyWord = '', indentTemp = stream.column(), letter;\n                        /**\n                        Either\n                        (indent-word ..\n                        (non-indent-word ..\n                        (;something else, bracket, etc.\n                        */\n\n                        if (ch == \"(\") while ((letter = stream.eat(tests.keyword_char)) != null) {\n                            keyWord += letter;\n                        }\n\n                        if (keyWord.length > 0 && (indentKeys.propertyIsEnumerable(keyWord) ||\n                                                   tests.block_indent.test(keyWord))) { // indent-word\n                            pushStack(state, indentTemp + INDENT_WORD_SKIP, ch);\n                        } else { // non-indent word\n                            // we continue eating the spaces\n                            stream.eatSpace();\n                            if (stream.eol() || stream.peek() == \";\") {\n                                // nothing significant after\n                                // we restart indentation the user defined spaces after\n                                pushStack(state, indentTemp + NORMAL_INDENT_UNIT, ch);\n                            } else {\n                                pushStack(state, indentTemp + stream.current().length, ch); // else we match\n                            }\n                        }\n                        stream.backUp(stream.current().length - 1); // undo all the eating\n\n                        returnType = BRACKET;\n                    } else if (ch == \")\" || ch == \"]\" || ch == \"}\") {\n                        returnType = BRACKET;\n                        if (state.indentStack != null && state.indentStack.type == (ch == \")\" ? \"(\" : (ch == \"]\" ? \"[\" :\"{\"))) {\n                            popStack(state);\n                        }\n                    } else if ( ch == \":\" ) {\n                        stream.eatWhile(tests.symbol);\n                        return ATOM;\n                    } else {\n                        stream.eatWhile(tests.symbol);\n\n                        if (keywords && keywords.propertyIsEnumerable(stream.current())) {\n                            returnType = KEYWORD;\n                        } else if (builtins && builtins.propertyIsEnumerable(stream.current())) {\n                            returnType = BUILTIN;\n                        } else if (atoms && atoms.propertyIsEnumerable(stream.current())) {\n                            returnType = ATOM;\n                        } else {\n                          returnType = VAR;\n                        }\n                    }\n            }\n\n            return returnType;\n        },\n\n        indent: function (state) {\n            if (state.indentStack == null) return state.indentation;\n            return state.indentStack.indent;\n        },\n\n        closeBrackets: {pairs: \"()[]{}\\\"\\\"\"},\n        lineComment: \";;\"\n    };\n});\n\nCodeMirror.defineMIME(\"text/x-clojure\", \"clojure\");\nCodeMirror.defineMIME(\"text/x-clojurescript\", \"clojure\");\nCodeMirror.defineMIME(\"application/edn\", \"clojure\");\n\n});\n"]}