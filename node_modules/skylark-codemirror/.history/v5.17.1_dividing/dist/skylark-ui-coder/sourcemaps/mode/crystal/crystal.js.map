{"version":3,"sources":["mode/crystal/crystal.js"],"names":["define","CodeMirror","defineMode","config","wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","idents","eat","current","keywords","test","indentKeywords","blocks","indexOf","currentIndent","dedentKeywords","pop","nextTokenizer","hasOwnProperty","atomWords","tokenNest","types","tokenQuote","operators","conditionalOperators","indexingOperators","delim","style","embed","next","matching","anotherOperators","begin","started","length","nextStyle","tokenMacroDef","tokenFollowIdent","tokenFollowType","escaped","ch","indentKeywordsArray","dedentKeywordsArray","dedentPunctualsArray","dedentPunctuals","def","fun","macro","class","module","struct","lib","enum","union","[","{","(","<","startState","token","indent","textAfter","replace","indentUnit","fold","electricInput","concat","lineComment","defineMIME"],"mappings":"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","file":"../../../mode/crystal/crystal.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function(config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\n      \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n      \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"ifdef\",\n      \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n      \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"sizeof\", \"struct\",\n      \"super\", \"then\", \"type\", \"typeof\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n      \"yield\", \"__DIR__\", \"__FILE__\", \"__LINE__\"\n    ]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\n      \"def\", \"fun\", \"macro\",\n      \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n      \"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\",\n      \"do\",\n      \"for\", \"ifdef\"\n    ];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var dedentKeywordsArray = [\n      \"end\",\n      \"else\", \"elsif\",\n      \"rescue\", \"ensure\"\n    ];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n    };\n    var matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Macros\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      }\n\n      // Comments\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Variables and keywords\n      var matched;\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n\n        matched = stream.current();\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (state.lastToken != \"abstract\" && indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0)) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if (dedentKeywords.test(matched)) {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      }\n\n      // Class variables and instance variables\n      // or attributes\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      }\n\n      // Global variables\n      if (stream.eat(\"$\")) {\n        stream.eat(/[0-9]+|\\?/) || stream.match(idents) || stream.match(types);\n        return \"variable-3\";\n      }\n\n      // Constants and types\n      if (stream.match(types)) {\n        return \"tag\";\n      }\n\n      // Symbols or ':' operator\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) ||\n                   stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n        stream.eat(\":\");\n        return \"operator\";\n      }\n\n      // Strings\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      }\n\n      // Strings or regexps or macro variables or '%' operator\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if(delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z0-9_\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      }\n\n      // Characters\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      }\n\n      // Numbers\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01]+/);\n        }\n        return \"number\";\n      }\n\n      if (stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      }\n\n      // Parens and braces\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      }\n\n      // Escapes\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          blocks: []\n        };\n      },\n\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n        }\n\n        return style;\n      },\n\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});\n"]}