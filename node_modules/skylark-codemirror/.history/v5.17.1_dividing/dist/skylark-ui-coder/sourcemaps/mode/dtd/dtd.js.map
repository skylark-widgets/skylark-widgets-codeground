{"version":3,"sources":["mode/dtd/dtd.js"],"names":["define","CodeMirror","defineMode","config","ret","style","tp","type","tokenBase","stream","state","ch","next","eat","tokenize","inBlock","eatWhile","match","tokenString","sc","current","substr","length","backUp","tokenSGMLComment","dashes","quote","escaped","terminator","eol","indentUnit","startState","base","baseIndent","stack","token","eatSpace","context","push","pop","indent","textAfter","n","electricChars","defineMIME"],"mappings":"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","file":"../../../mode/dtd/dtd.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/*\n  DTD mode\n  Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>\n  Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues\n  GitHub: @peterkroon\n*/\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"dtd\", function(config) {\n  var indentUnit = config.indentUnit, type;\n  function ret(style, tp) {type = tp; return style;}\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    if (ch == \"<\" && stream.eat(\"!\") ) {\n      if (stream.eatWhile(/[\\-]/)) {\n        state.tokenize = tokenSGMLComment;\n        return tokenSGMLComment(stream, state);\n      } else if (stream.eatWhile(/[\\w]/)) return ret(\"keyword\", \"doindent\");\n    } else if (ch == \"<\" && stream.eat(\"?\")) { //xml declaration\n      state.tokenize = inBlock(\"meta\", \"?>\");\n      return ret(\"meta\", ch);\n    } else if (ch == \"#\" && stream.eatWhile(/[\\w]/)) return ret(\"atom\", \"tag\");\n    else if (ch == \"|\") return ret(\"keyword\", \"seperator\");\n    else if (ch.match(/[\\(\\)\\[\\]\\-\\.,\\+\\?>]/)) return ret(null, ch);//if(ch === \">\") return ret(null, \"endtag\"); else\n    else if (ch.match(/[\\[\\]]/)) return ret(\"rule\", ch);\n    else if (ch == \"\\\"\" || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (stream.eatWhile(/[a-zA-Z\\?\\+\\d]/)) {\n      var sc = stream.current();\n      if( sc.substr(sc.length-1,sc.length).match(/\\?|\\+/) !== null )stream.backUp(1);\n      return ret(\"tag\", \"tag\");\n    } else if (ch == \"%\" || ch == \"*\" ) return ret(\"number\", \"number\");\n    else {\n      stream.eatWhile(/[\\w\\\\\\-_%.{,]/);\n      return ret(null, null);\n    }\n  }\n\n  function tokenSGMLComment(stream, state) {\n    var dashes = 0, ch;\n    while ((ch = stream.next()) != null) {\n      if (dashes >= 2 && ch == \">\") {\n        state.tokenize = tokenBase;\n        break;\n      }\n      dashes = (ch == \"-\") ? dashes + 1 : 0;\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      return ret(\"string\", \"tag\");\n    };\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n\n  return {\n    startState: function(base) {\n      return {tokenize: tokenBase,\n              baseIndent: base || 0,\n              stack: []};\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n\n      var context = state.stack[state.stack.length-1];\n      if (stream.current() == \"[\" || type === \"doindent\" || type == \"[\") state.stack.push(\"rule\");\n      else if (type === \"endtag\") state.stack[state.stack.length-1] = \"endtag\";\n      else if (stream.current() == \"]\" || type == \"]\" || (type == \">\" && context == \"rule\")) state.stack.pop();\n      else if (type == \"[\") state.stack.push(\"[\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var n = state.stack.length;\n\n      if( textAfter.match(/\\]\\s+|\\]/) )n=n-1;\n      else if(textAfter.substr(textAfter.length-1, textAfter.length) === \">\"){\n        if(textAfter.substr(0,1) === \"<\") {}\n        else if( type == \"doindent\" && textAfter.length > 1 ) {}\n        else if( type == \"doindent\")n--;\n        else if( type == \">\" && textAfter.length > 1) {}\n        else if( type == \"tag\" && textAfter !== \">\") {}\n        else if( type == \"tag\" && state.stack[state.stack.length-1] == \"rule\")n--;\n        else if( type == \"tag\")n++;\n        else if( textAfter === \">\" && state.stack[state.stack.length-1] == \"rule\" && type === \">\")n--;\n        else if( textAfter === \">\" && state.stack[state.stack.length-1] == \"rule\") {}\n        else if( textAfter.substr(0,1) !== \"<\" && textAfter.substr(0,1) === \">\" )n=n-1;\n        else if( textAfter === \">\") {}\n        else n=n-1;\n        //over rule them all\n        if(type == null || type == \"]\")n--;\n      }\n\n      return state.baseIndent + n * indentUnit;\n    },\n\n    electricChars: \"]>\"\n  };\n});\n\nCodeMirror.defineMIME(\"application/xml-dtd\", \"dtd\");\n\n});\n"]}