{"version":3,"sources":["mode/haml/haml.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","rubyInQuote","endQuote","stream","state","ch","peek","rubyState","tokenize","length","next","html","ruby","match","skipToEnd","rubyMode","token","previousToken","style","indented","startOfLine","htmlMode","htmlState","getMode","name","startState","copyState","sol","indentation","eatSpace","eol","backUp","defineMIME"],"mappings":"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","file":"../../../mode/haml/haml.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../Coder\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../Coder\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n  // full haml mode. This handled embedded ruby and html fragments too\n  CodeMirror.defineMode(\"haml\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n\n    function rubyInQuote(endQuote) {\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = html;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function ruby(stream, state) {\n      if (stream.match(\"-#\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function html(stream, state) {\n      var ch = stream.peek();\n\n      // handle haml declarations. All declarations that cant be handled here\n      // will be passed to html mode\n      if (state.previousToken.style == \"comment\" ) {\n        if (state.indented > state.previousToken.indented) {\n          stream.skipToEnd();\n          return \"commentLine\";\n        }\n      }\n\n      if (state.startOfLine) {\n        if (ch == \"!\" && stream.match(\"!!\")) {\n          stream.skipToEnd();\n          return \"tag\";\n        } else if (stream.match(/^%[\\w:#\\.]+=/)) {\n          state.tokenize = ruby;\n          return \"hamlTag\";\n        } else if (stream.match(/^%[\\w:]+/)) {\n          return \"hamlTag\";\n        } else if (ch == \"/\" ) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (state.startOfLine || state.previousToken.style == \"hamlTag\") {\n        if ( ch == \"#\" || ch == \".\") {\n          stream.match(/[\\w-#\\.]*/);\n          return \"hamlAttribute\";\n        }\n      }\n\n      // donot handle --> as valid ruby, make it HTML close comment instead\n      if (state.startOfLine && !stream.match(\"-->\", false) && (ch == \"=\" || ch == \"-\" )) {\n        state.tokenize = ruby;\n        return state.tokenize(stream, state);\n      }\n\n      if (state.previousToken.style == \"hamlTag\" ||\n          state.previousToken.style == \"closeAttributeTag\" ||\n          state.previousToken.style == \"hamlAttribute\") {\n        if (ch == \"(\") {\n          state.tokenize = rubyInQuote(\")\");\n          return state.tokenize(stream, state);\n        } else if (ch == \"{\") {\n          if (!stream.match(/^\\{%.*/)) {\n            state.tokenize = rubyInQuote(\"}\");\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n\n      return htmlMode.token(stream, state.htmlState);\n    }\n\n    return {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          indented: 0,\n          previousToken: { style: null, indented: 0},\n          tokenize: html\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          indented: state.indented,\n          previousToken: state.previousToken,\n          tokenize: state.tokenize\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        // dont record comment line as we only want to measure comment line with\n        // the opening comment block\n        if (style && style != \"commentLine\") {\n          state.previousToken = { style: style, indented: state.indented };\n        }\n        // if current state is ruby and the previous token is not `,` reset the\n        // tokenize to html\n        if (stream.eol() && state.tokenize == ruby) {\n          stream.backUp(1);\n          var ch = stream.peek();\n          stream.next();\n          if (ch && ch != \",\") {\n            state.tokenize = html;\n          }\n        }\n        // reprocess some of the specific style tag when finish setting previousToken\n        if (style == \"hamlTag\") {\n          style = \"tag\";\n        } else if (style == \"commentLine\") {\n          style = \"comment\";\n        } else if (style == \"hamlAttribute\") {\n          style = \"attribute\";\n        } else if (style == \"closeAttributeTag\") {\n          style = null;\n        }\n        return style;\n      }\n    };\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-haml\", \"haml\");\n});\n"]}