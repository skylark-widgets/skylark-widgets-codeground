{"version":3,"sources":["mode/javascript/javascript.js"],"names":["define","CodeMirror","expressionAllowed","stream","state","backUp","test","lastType","string","slice","pos","defineMode","config","parserConfig","readRegexp","next","escaped","inSet","ret","tp","style","cont","type","content","tokenBase","ch","tokenize","tokenString","match","eat","eatWhile","tokenComment","skipToEnd","isOperatorChar","current","tokenQuasi","wordRE","word","known","keywords","propertyIsEnumerable","quote","jsonldMode","peek","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","indexOf","start","depth","sawSomething","charAt","bracket","brackets","JSLexical","indented","column","align","prev","info","this","inScope","varname","v","localVars","name","cx","context","vars","parseJS","cc","marked","lexical","hasOwnProperty","combinator","length","pop","jsonMode","expression","statement","lex","pass","i","arguments","push","apply","register","inList","list","globalVars","pushcontext","defaultVars","popcontext","pushlex","result","indent","outer","poplex","expect","wanted","exp","value","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","className","afterExport","afterImport","pattern","expressionInner","expressionNoComma","noComma","body","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","arrayLiteral","contCommasep","objprop","quasi","maybeTarget","me","expr","property","continueQuasi","targetNoComma","target","_","getterSetter","afterprop","what","end","proceed","maybetype","isTS","typeexpr","maybedefault","afterType","typeprop","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","classBody","classGetterSetter","maybeFrom","importSpec","maybeAs","isContinuedStatement","textAfter","indentUnit","statementIndent","jsonld","json","typescript","wordCharacters","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","typeof","instanceof","true","false","null","undefined","NaN","Infinity","class","super","yield","export","import","extends","await","async","tsKeywords","interface","implements","namespace","module","enum","public","private","protected","abstract","as","number","boolean","any","attr","variable","regexp","jsonld-keyword","startState","basecolumn","token","sol","indentation","eatSpace","Pass","firstChar","c","closing","doubleIndentSwitch","electricInput","blockCommentStart","blockCommentEnd","lineComment","fold","closeBrackets","helperType","skipExpression","top","registerHelper","defineMIME"],"mappings":"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","file":"../../../mode/javascript/javascript.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// TODO actually recognize syntax of TypeScript constructs\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nfunction expressionAllowed(stream, state, backUp) {\n  return /^(?:operator|sof|keyword c|case|new|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n    (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n}\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": kw(\"new\"), \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C, \"async\": kw(\"async\")\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"class\"),\n        \"implements\": C,\n        \"namespace\": C,\n        \"module\": kw(\"module\"),\n        \"enum\": kw(\"module\"),\n\n        // scope modifiers\n        \"public\": kw(\"modifier\"),\n        \"private\": kw(\"modifier\"),\n        \"protected\": kw(\"modifier\"),\n        \"abstract\": kw(\"modifier\"),\n\n        // operators\n        \"as\": operator,\n\n        // types\n        \"string\": type, \"number\": type, \"boolean\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/o/i)) {\n      stream.eatWhile(/[0-7]/i);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"0\" && stream.eat(/b/i)) {\n      stream.eatWhile(/[01]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyu])(?![gimyu]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, poplex);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"module\") return cont(pushlex(\"form\"), pattern, pushlex(\"}\"), expect(\"{\"), block, poplex, poplex)\n    if (type == \"async\") return cont(statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") return cont(objprop);\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (type == \"modifier\") {\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expression);\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type, value) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typeexpr);\n  }\n  function maybedefault(_, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function typeexpr(type) {\n    if (type == \"variable\") {cx.marked = \"variable-3\"; return cont(afterType);}\n    if (type == \"{\") return cont(commasep(typeprop, \"}\"))\n  }\n  function typeprop(type) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    }\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(commasep(typeexpr, \">\"), afterType)\n    if (type == \"[\") return cont(expect(\"]\"), afterType)\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"modifier\") return cont(pattern)\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, maybetype, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype, maybedefault);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"extends\") return cont(expression, classNameAfter);\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      if (value == \"static\") {\n        cx.marked = \"keyword\";\n        return cont(classBody);\n      }\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(classGetterSetter, functiondef, classBody);\n      return cont(functiondef, classBody);\n    }\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \";\") return cont(classBody);\n    if (type == \"}\") return cont();\n  }\n  function classGetterSetter(type) {\n    if (type != \"variable\") return pass();\n    cx.marked = \"property\";\n    return cont();\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n"]}