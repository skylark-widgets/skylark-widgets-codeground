{"version":3,"sources":["mode/julia/julia.js"],"names":["define","CodeMirror","defineMode","_conf","parserConf","wordRegexp","words","end","RegExp","join","inArray","state","ch","currentScope","scopes","length","tokenBase","stream","match","tokenize","tokenComment","leavingExpr","sol","eatSpace","peek","skipToEnd","push","scope","pop","openers","closers","lastToken","imMatcher","numberLiteral","typeAnnotation","symbol","operators","tokenChar","stringPrefixes","tokenStringFactory","current","macro","delimiters","keywords","builtins","isDefinition","identifiers","callOrDef","next","ERRORCLASS","firstParenPos","charsAdvanced","backUp","weakScopes","isChar","chars","value","parseInt","delimiter","tokenString","eol","eatWhile","eat","OUTCLASS","indexOf","charAt","toLowerCase","substr","isString","octChar","hexChar","specialChar","singleChar","charsList","blockOpeners","blockClosers","keywordList","builtinList","external","startState","token","style","indent","textAfter","delta","indentUnit","electricInput","lineComment","fold","defineMIME"],"mappings":"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","file":"../../../mode/julia/julia.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"julia\", function(_conf, parserConf) {\n  var ERRORCLASS = 'error';\n\n  function wordRegexp(words, end) {\n    if (typeof end === 'undefined') { end = \"\\\\b\"; }\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\" + end);\n  }\n\n  var octChar = \"\\\\\\\\[0-7]{1,3}\";\n  var hexChar = \"\\\\\\\\x[A-Fa-f0-9]{1,2}\";\n  var specialChar = \"\\\\\\\\[abfnrtv0%?'\\\"\\\\\\\\]\";\n  var singleChar = \"([^\\\\u0027\\\\u005C\\\\uD800-\\\\uDFFF]|[\\\\uD800-\\\\uDFFF][\\\\uDC00-\\\\uDFFF])\";\n  var operators = parserConf.operators || /^\\.?[|&^\\\\%*+\\-<>!=\\/]=?|\\?|~|:|\\$|\\.[<>]|<<=?|>>>?=?|\\.[<>=]=|->?|\\/\\/|\\bin\\b(?!\\()|[\\u2208\\u2209](?!\\()/;\n  var delimiters = parserConf.delimiters || /^[;,()[\\]{}]/;\n  var identifiers = parserConf.identifiers || /^[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\n  var charsList = [octChar, hexChar, specialChar, singleChar];\n  var blockOpeners = [\"begin\", \"function\", \"type\", \"immutable\", \"let\", \"macro\", \"for\", \"while\", \"quote\", \"if\", \"else\", \"elseif\", \"try\", \"finally\", \"catch\", \"do\"];\n  var blockClosers = [\"end\", \"else\", \"elseif\", \"catch\", \"finally\"];\n  var keywordList = ['if', 'else', 'elseif', 'while', 'for', 'begin', 'let', 'end', 'do', 'try', 'catch', 'finally', 'return', 'break', 'continue', 'global', 'local', 'const', 'export', 'import', 'importall', 'using', 'function', 'macro', 'module', 'baremodule', 'type', 'immutable', 'quote', 'typealias', 'abstract', 'bitstype'];\n  var builtinList = ['true', 'false', 'nothing', 'NaN', 'Inf'];\n\n  //var stringPrefixes = new RegExp(\"^[br]?('|\\\")\")\n  var stringPrefixes = /^(`|\"{3}|([brv]?\"))/;\n  var chars = wordRegexp(charsList, \"'\");\n  var keywords = wordRegexp(keywordList);\n  var builtins = wordRegexp(builtinList);\n  var openers = wordRegexp(blockOpeners);\n  var closers = wordRegexp(blockClosers);\n  var macro = /^@[_A-Za-z][\\w]*/;\n  var symbol = /^:[_A-Za-z\\u00A1-\\uFFFF][\\w\\u00A1-\\uFFFF]*!*/;\n  var typeAnnotation = /^::[^,;\"{()=$\\s]+({[^}]*}+)*/;\n\n  function inArray(state) {\n    var ch = currentScope(state);\n    if (ch == '[') {\n      return true;\n    }\n    return false;\n  }\n\n  function currentScope(state) {\n    if (state.scopes.length == 0) {\n      return null;\n    }\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  // tokenizers\n  function tokenBase(stream, state) {\n    // Handle multiline comments\n    if (stream.match(/^#=/, false)) {\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Handle scope changes\n    var leavingExpr = state.leavingExpr;\n    if (stream.sol()) {\n      leavingExpr = false;\n    }\n    state.leavingExpr = false;\n    if (leavingExpr) {\n      if (stream.match(/^'+/)) {\n        return 'operator';\n      }\n    }\n\n    if (stream.match(/^\\.{2,3}/)) {\n      return 'operator';\n    }\n\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle single line comments\n    if (ch === '#') {\n      stream.skipToEnd();\n      return 'comment';\n    }\n\n    if (ch === '[') {\n      state.scopes.push('[');\n    }\n\n    if (ch === '(') {\n      state.scopes.push('(');\n    }\n\n    var scope = currentScope(state);\n\n    if (scope == '[' && ch === ']') {\n      state.scopes.pop();\n      state.leavingExpr = true;\n    }\n\n    if (scope == '(' && ch === ')') {\n      state.scopes.pop();\n      state.leavingExpr = true;\n    }\n\n    var match;\n    if (!inArray(state) && (match=stream.match(openers, false))) {\n      state.scopes.push(match);\n    }\n\n    if (!inArray(state) && stream.match(closers, false)) {\n      state.scopes.pop();\n    }\n\n    if (inArray(state)) {\n      if (state.lastToken == 'end' && stream.match(/^:/)) {\n        return 'operator';\n      }\n      if (stream.match(/^end/)) {\n        return 'number';\n      }\n    }\n\n    if (stream.match(/^=>/)) {\n      return 'operator';\n    }\n\n    // Handle Number Literals\n    if (stream.match(/^[0-9\\.]/, false)) {\n      var imMatcher = RegExp(/^im\\b/);\n      var numberLiteral = false;\n      // Floats\n      if (stream.match(/^\\d*\\.(?!\\.)\\d*([Eef][\\+\\-]?\\d+)?/i)) { numberLiteral = true; }\n      if (stream.match(/^\\d+\\.(?!\\.)\\d*/)) { numberLiteral = true; }\n      if (stream.match(/^\\.\\d+/)) { numberLiteral = true; }\n      if (stream.match(/^0x\\.[0-9a-f]+p[\\+\\-]?\\d+/i)) { numberLiteral = true; }\n      // Integers\n      if (stream.match(/^0x[0-9a-f]+/i)) { numberLiteral = true; } // Hex\n      if (stream.match(/^0b[01]+/i)) { numberLiteral = true; } // Binary\n      if (stream.match(/^0o[0-7]+/i)) { numberLiteral = true; } // Octal\n      if (stream.match(/^[1-9]\\d*(e[\\+\\-]?\\d+)?/)) { numberLiteral = true; } // Decimal\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^0(?![\\dx])/i)) { numberLiteral = true; }\n      if (numberLiteral) {\n          // Integer literals may be \"long\"\n          stream.match(imMatcher);\n          state.leavingExpr = true;\n          return 'number';\n      }\n    }\n\n    if (stream.match(/^<:/)) {\n      return 'operator';\n    }\n\n    if (stream.match(typeAnnotation)) {\n      return 'builtin';\n    }\n\n    // Handle symbols\n    if (!leavingExpr && stream.match(symbol) || stream.match(/:\\./)) {\n      return 'builtin';\n    }\n\n    // Handle parametric types\n    if (stream.match(/^{[^}]*}(?=\\()/)) {\n      return 'builtin';\n    }\n\n    // Handle operators and Delimiters\n    if (stream.match(operators)) {\n      return 'operator';\n    }\n\n    // Handle Chars\n    if (stream.match(/^'/)) {\n      state.tokenize = tokenChar;\n      return state.tokenize(stream, state);\n    }\n\n    // Handle Strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenStringFactory(stream.current());\n      return state.tokenize(stream, state);\n    }\n\n    if (stream.match(macro)) {\n      return 'meta';\n    }\n\n    if (stream.match(delimiters)) {\n      return null;\n    }\n\n    if (stream.match(keywords)) {\n      return 'keyword';\n    }\n\n    if (stream.match(builtins)) {\n      return 'builtin';\n    }\n\n    var isDefinition = state.isDefinition ||\n                       state.lastToken == 'function' ||\n                       state.lastToken == 'macro' ||\n                       state.lastToken == 'type' ||\n                       state.lastToken == 'immutable';\n\n    if (stream.match(identifiers)) {\n      if (isDefinition) {\n        if (stream.peek() === '.') {\n          state.isDefinition = true;\n          return 'variable';\n        }\n        state.isDefinition = false;\n        return 'def';\n      }\n      if (stream.match(/^({[^}]*})*\\(/, false)) {\n        return callOrDef(stream, state);\n      }\n      state.leavingExpr = true;\n      return 'variable';\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function callOrDef(stream, state) {\n    var match = stream.match(/^(\\(\\s*)/);\n    if (match) {\n      if (state.firstParenPos < 0)\n        state.firstParenPos = state.scopes.length;\n      state.scopes.push('(');\n      state.charsAdvanced += match[1].length;\n    }\n    if (currentScope(state) == '(' && stream.match(/^\\)/)) {\n      state.scopes.pop();\n      state.charsAdvanced += 1;\n      if (state.scopes.length <= state.firstParenPos) {\n        var isDefinition = stream.match(/^\\s*?=(?!=)/, false);\n        stream.backUp(state.charsAdvanced);\n        state.firstParenPos = -1;\n        state.charsAdvanced = 0;\n        if (isDefinition)\n          return 'def';\n        return 'builtin';\n      }\n    }\n    // Unfortunately javascript does not support multiline strings, so we have\n    // to undo anything done upto here if a function call or definition splits\n    // over two or more lines.\n    if (stream.match(/^$/g, false)) {\n      stream.backUp(state.charsAdvanced);\n      while (state.scopes.length > state.firstParenPos)\n        state.scopes.pop();\n      state.firstParenPos = -1;\n      state.charsAdvanced = 0;\n      return 'builtin';\n    }\n    state.charsAdvanced += stream.match(/^([^()]*)/)[1].length;\n    return callOrDef(stream, state);\n  }\n\n  function tokenComment(stream, state) {\n    if (stream.match(/^#=/)) {\n      state.weakScopes++;\n    }\n    if (!stream.match(/.*?(?=(#=|=#))/)) {\n      stream.skipToEnd();\n    }\n    if (stream.match(/^=#/)) {\n      state.weakScopes--;\n      if (state.weakScopes == 0)\n        state.tokenize = tokenBase;\n    }\n    return 'comment';\n  }\n\n  function tokenChar(stream, state) {\n    var isChar = false, match;\n    if (stream.match(chars)) {\n      isChar = true;\n    } else if (match = stream.match(/\\\\u([a-f0-9]{1,4})(?=')/i)) {\n      var value = parseInt(match[1], 16);\n      if (value <= 55295 || value >= 57344) { // (U+0,U+D7FF), (U+E000,U+FFFF)\n        isChar = true;\n        stream.next();\n      }\n    } else if (match = stream.match(/\\\\U([A-Fa-f0-9]{5,8})(?=')/)) {\n      var value = parseInt(match[1], 16);\n      if (value <= 1114111) { // U+10FFFF\n        isChar = true;\n        stream.next();\n      }\n    }\n    if (isChar) {\n      state.leavingExpr = true;\n      state.tokenize = tokenBase;\n      return 'string';\n    }\n    if (!stream.match(/^[^']+(?=')/)) { stream.skipToEnd(); }\n    if (stream.match(/^'/)) { state.tokenize = tokenBase; }\n    return ERRORCLASS;\n  }\n\n  function tokenStringFactory(delimiter) {\n    while ('bruv'.indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {\n      delimiter = delimiter.substr(1);\n    }\n    var OUTCLASS = 'string';\n\n    function tokenString(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^\"\\\\]/);\n        if (stream.eat('\\\\')) {\n            stream.next();\n        } else if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            state.leavingExpr = true;\n            return OUTCLASS;\n        } else {\n            stream.eat(/[\"]/);\n        }\n      }\n      return OUTCLASS;\n    }\n    tokenString.isString = true;\n    return tokenString;\n  }\n\n  var external = {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        scopes: [],\n        weakScopes: 0,\n        lastToken: null,\n        leavingExpr: false,\n        isDefinition: false,\n        charsAdvanced: 0,\n        firstParenPos: -1\n      };\n    },\n\n    token: function(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      if (current && style) {\n        state.lastToken = current;\n      }\n\n      // Handle '.' connected identifiers\n      if (current === '.') {\n        style = stream.match(identifiers, false) || stream.match(macro, false) ||\n                stream.match(/\\(/, false) ? 'operator' : ERRORCLASS;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var delta = 0;\n      if (textAfter == \"]\" || textAfter == \")\" || textAfter == \"end\" || textAfter == \"else\" || textAfter == \"elseif\" || textAfter == \"catch\" || textAfter == \"finally\") {\n        delta = -1;\n      }\n      return (state.scopes.length + delta) * _conf.indentUnit;\n    },\n\n    electricInput: /(end|else(if)?|catch|finally)$/,\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n  return external;\n});\n\n\nCodeMirror.defineMIME(\"text/x-julia\", \"julia\");\n\n});\n"]}