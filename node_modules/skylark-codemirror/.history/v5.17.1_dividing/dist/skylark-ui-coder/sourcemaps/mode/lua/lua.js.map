{"version":3,"sources":["mode/lua/lua.js"],"names":["define","CodeMirror","defineMode","config","parserConfig","prefixRE","words","RegExp","join","wordRE","readBracket","stream","level","eat","normal","state","ch","next","cur","bracketed","skipToEnd","string","test","peek","eatWhile","style","curlev","quote","escaped","indentUnit","specials","builtins","keywords","indentTokens","dedentTokens","dedentPartial","startState","basecol","indentDepth","token","eatSpace","word","current","indent","textAfter","closing","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"../../../mode/lua/lua.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// LUA mode. Ported to CodeMirror 2 from Franciszek Wawrzak's\n// CodeMirror 1 mode.\n// highlights keywords, strings, comments (no leveling supported! (\"[==[\")), tokens, basic indenting\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"lua\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  function prefixRE(words) {\n    return new RegExp(\"^(?:\" + words.join(\"|\") + \")\", \"i\");\n  }\n  function wordRE(words) {\n    return new RegExp(\"^(?:\" + words.join(\"|\") + \")$\", \"i\");\n  }\n  var specials = wordRE(parserConfig.specials || []);\n\n  // long list of standard functions from lua manual\n  var builtins = wordRE([\n    \"_G\",\"_VERSION\",\"assert\",\"collectgarbage\",\"dofile\",\"error\",\"getfenv\",\"getmetatable\",\"ipairs\",\"load\",\n    \"loadfile\",\"loadstring\",\"module\",\"next\",\"pairs\",\"pcall\",\"print\",\"rawequal\",\"rawget\",\"rawset\",\"require\",\n    \"select\",\"setfenv\",\"setmetatable\",\"tonumber\",\"tostring\",\"type\",\"unpack\",\"xpcall\",\n\n    \"coroutine.create\",\"coroutine.resume\",\"coroutine.running\",\"coroutine.status\",\"coroutine.wrap\",\"coroutine.yield\",\n\n    \"debug.debug\",\"debug.getfenv\",\"debug.gethook\",\"debug.getinfo\",\"debug.getlocal\",\"debug.getmetatable\",\n    \"debug.getregistry\",\"debug.getupvalue\",\"debug.setfenv\",\"debug.sethook\",\"debug.setlocal\",\"debug.setmetatable\",\n    \"debug.setupvalue\",\"debug.traceback\",\n\n    \"close\",\"flush\",\"lines\",\"read\",\"seek\",\"setvbuf\",\"write\",\n\n    \"io.close\",\"io.flush\",\"io.input\",\"io.lines\",\"io.open\",\"io.output\",\"io.popen\",\"io.read\",\"io.stderr\",\"io.stdin\",\n    \"io.stdout\",\"io.tmpfile\",\"io.type\",\"io.write\",\n\n    \"math.abs\",\"math.acos\",\"math.asin\",\"math.atan\",\"math.atan2\",\"math.ceil\",\"math.cos\",\"math.cosh\",\"math.deg\",\n    \"math.exp\",\"math.floor\",\"math.fmod\",\"math.frexp\",\"math.huge\",\"math.ldexp\",\"math.log\",\"math.log10\",\"math.max\",\n    \"math.min\",\"math.modf\",\"math.pi\",\"math.pow\",\"math.rad\",\"math.random\",\"math.randomseed\",\"math.sin\",\"math.sinh\",\n    \"math.sqrt\",\"math.tan\",\"math.tanh\",\n\n    \"os.clock\",\"os.date\",\"os.difftime\",\"os.execute\",\"os.exit\",\"os.getenv\",\"os.remove\",\"os.rename\",\"os.setlocale\",\n    \"os.time\",\"os.tmpname\",\n\n    \"package.cpath\",\"package.loaded\",\"package.loaders\",\"package.loadlib\",\"package.path\",\"package.preload\",\n    \"package.seeall\",\n\n    \"string.byte\",\"string.char\",\"string.dump\",\"string.find\",\"string.format\",\"string.gmatch\",\"string.gsub\",\n    \"string.len\",\"string.lower\",\"string.match\",\"string.rep\",\"string.reverse\",\"string.sub\",\"string.upper\",\n\n    \"table.concat\",\"table.insert\",\"table.maxn\",\"table.remove\",\"table.sort\"\n  ]);\n  var keywords = wordRE([\"and\",\"break\",\"elseif\",\"false\",\"nil\",\"not\",\"or\",\"return\",\n                         \"true\",\"function\", \"end\", \"if\", \"then\", \"else\", \"do\",\n                         \"while\", \"repeat\", \"until\", \"for\", \"in\", \"local\" ]);\n\n  var indentTokens = wordRE([\"function\", \"if\",\"repeat\",\"do\", \"\\\\(\", \"{\"]);\n  var dedentTokens = wordRE([\"end\", \"until\", \"\\\\)\", \"}\"]);\n  var dedentPartial = prefixRE([\"end\", \"until\", \"\\\\)\", \"}\", \"else\", \"elseif\"]);\n\n  function readBracket(stream) {\n    var level = 0;\n    while (stream.eat(\"=\")) ++level;\n    stream.eat(\"[\");\n    return level;\n  }\n\n  function normal(stream, state) {\n    var ch = stream.next();\n    if (ch == \"-\" && stream.eat(\"-\")) {\n      if (stream.eat(\"[\") && stream.eat(\"[\"))\n        return (state.cur = bracketed(readBracket(stream), \"comment\"))(stream, state);\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (ch == \"\\\"\" || ch == \"'\")\n      return (state.cur = string(ch))(stream, state);\n    if (ch == \"[\" && /[\\[=]/.test(stream.peek()))\n      return (state.cur = bracketed(readBracket(stream), \"string\"))(stream, state);\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w.%]/);\n      return \"number\";\n    }\n    if (/[\\w_]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-_.]/);\n      return \"variable\";\n    }\n    return null;\n  }\n\n  function bracketed(level, style) {\n    return function(stream, state) {\n      var curlev = null, ch;\n      while ((ch = stream.next()) != null) {\n        if (curlev == null) {if (ch == \"]\") curlev = 0;}\n        else if (ch == \"=\") ++curlev;\n        else if (ch == \"]\" && curlev == level) { state.cur = normal; break; }\n        else curlev = null;\n      }\n      return style;\n    };\n  }\n\n  function string(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) break;\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (!escaped) state.cur = normal;\n      return \"string\";\n    };\n  }\n\n  return {\n    startState: function(basecol) {\n      return {basecol: basecol || 0, indentDepth: 0, cur: normal};\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.cur(stream, state);\n      var word = stream.current();\n      if (style == \"variable\") {\n        if (keywords.test(word)) style = \"keyword\";\n        else if (builtins.test(word)) style = \"builtin\";\n        else if (specials.test(word)) style = \"variable-2\";\n      }\n      if ((style != \"comment\") && (style != \"string\")){\n        if (indentTokens.test(word)) ++state.indentDepth;\n        else if (dedentTokens.test(word)) --state.indentDepth;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var closing = dedentPartial.test(textAfter);\n      return state.basecol + indentUnit * (state.indentDepth - (closing ? 1 : 0));\n    },\n\n    lineComment: \"--\",\n    blockCommentStart: \"--[[\",\n    blockCommentEnd: \"]]\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-lua\", \"lua\");\n\n});\n"]}