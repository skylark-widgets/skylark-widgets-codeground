{"version":3,"sources":["mode/octave/octave.js"],"names":["define","CodeMirror","defineMode","wordRegexp","words","RegExp","join","tokenTranspose","stream","state","sol","peek","tokenize","tokenBase","next","tokenComment","match","skipToEnd","eatSpace","keywords","builtins","identifiers","singleOperators","doubleOperators","singleDelimiters","doubleDelimiters","tripleDelimiters","expressionEnd","startState","token","style","defineMIME"],"mappings":";;;;;;;AAGAA,QAAQ,eAAgB,SAASC,GACjC,YAEAA,GAAWC,WAAW,SAAU,WAC9B,QAASC,GAAWC,GAClB,MAAO,IAAIC,QAAO,MAAQD,EAAME,KAAK,OAAS,SA8BhD,QAASC,GAAeC,EAAQC,GAC9B,MAAKD,GAAOE,OAA2B,MAAlBF,EAAOG,QAK5BF,EAAMG,SAAWC,EACVA,EAAUL,EAAQC,KALvBD,EAAOM,OACPL,EAAMG,SAAWC,EACV,YAOX,QAASE,GAAaP,EAAQC,GAC5B,MAAID,GAAOQ,MAAM,UACfP,EAAMG,SAAWC,EACV,YAETL,EAAOS,YACA,WAGT,QAASJ,GAAUL,EAAQC,GAEzB,GAAID,EAAOU,WAAY,MAAO,KAG9B,IAAIV,EAAOQ,MAAM,MAGf,MAFAP,GAAMG,SAAWG,EACjBP,EAAOS,YACA,SAGT,IAAIT,EAAOQ,MAAM,SAEf,MADAR,GAAOS,YACA,SAIT,IAAIT,EAAOQ,MAAM,cAAc,GAAQ,CACrC,GAAIR,EAAOQ,MAAM,6BAEf,MADAR,GAAOI,SAAWC,EACX,QACT,IAAIL,EAAOQ,MAAM,wCAA2C,MAAO,QACnE,IAAIR,EAAOQ,MAAM,mCAAsC,MAAO,SAEhE,MAAIR,GAAOQ,MAAMb,GAAY,MAAM,MAAM,MAAM,SAAmB,SAG9DK,EAAOQ,MAAM,mBAA6B,SAC1CR,EAAOQ,MAAM,mBAA6B,SAG1CR,EAAOQ,MAAMG,GAAoB,UACjCX,EAAOQ,MAAMI,GAAoB,UACjCZ,EAAOQ,MAAMK,GAAuB,WAEpCb,EAAOQ,MAAMM,IAAoBd,EAAOQ,MAAMO,GAA2B,WACzEf,EAAOQ,MAAMQ,IAAqBhB,EAAOQ,MAAMS,IAAqBjB,EAAOQ,MAAMU,GAA4B,KAE7GlB,EAAOQ,MAAMW,IACflB,EAAMG,SAAWL,EACV,OAKTC,EAAOM,OACA,SA7FT,GAAIQ,GAAkB,GAAIjB,QAAO,gCAC7BmB,EAAmB,GAAInB,QAAO,uBAC9BkB,EAAkB,GAAIlB,QAAO,6DAC7BoB,EAAmB,GAAIpB,QAAO,wDAC9BqB,EAAmB,GAAIrB,QAAO,kBAC9BsB,EAAgB,GAAItB,QAAO,aAC3BgB,EAAc,GAAIhB,QAAO,iCAEzBe,EAAWjB,GACb,QAAS,OAAQ,WAAY,MAAO,OAAQ,OAAQ,OAAQ,MAC5D,OAAQ,MAAO,MAAO,OAAQ,MAAO,QAAS,MAAO,MAAO,OAAQ,MAAO,OAC3E,OAAQ,MAAO,UAAW,QAAS,QAAS,UAAW,SAAU,QAAS,OAC1E,OAAQ,MAAO,OAAQ,QAAS,OAAQ,QAAS,QAAS,MAAO,OAAQ,MAAO,MAChF,MAAO,MAAO,MAAO,OAAQ,OAAQ,QAAS,OAAQ,OAAQ,QAAS,WAAY,OACnF,QAAS,SAAU,SAAU,SAAU,OAAQ,OAAQ,WAAY,OAAQ,UAC3E,MAAO,OAAQ,WAAY,UAAW,QAAS,SAAU,SAAU,aAGjEgB,EAAWhB,GACb,SAAU,OAAQ,SAAU,OAAQ,SAAU,MAAO,QAAS,cAC9D,KAAM,YAAa,KAAM,MAAO,QAAS,MAAO,QAAS,WAAY,aAAc,SACnF,UAAW,SAAU,aAAc,SAAU,WAAY,SAAU,UAAW,OAAQ,QACtF,WAAY,OA2Ed,QACEyB,WAAY,WACV,OACEhB,SAAUC,IAIdgB,MAAO,SAASrB,EAAQC,GACtB,GAAIqB,GAAQrB,EAAMG,SAASJ,EAAQC,EAInC,OAHc,WAAVqB,GAAgC,aAAVA,IACxBrB,EAAMG,SAAWL,GAEZuB,MAKb7B,EAAW8B,WAAW,gBAAiB","file":"../../../mode/octave/octave.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"octave\", function() {\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/&|\\\\^~<>!@'\\\\\\\\]\");\n  var singleDelimiters = new RegExp('^[\\\\(\\\\[\\\\{\\\\},:=;]');\n  var doubleOperators = new RegExp(\"^((==)|(~=)|(<=)|(>=)|(<<)|(>>)|(\\\\.[\\\\+\\\\-\\\\*/\\\\^\\\\\\\\]))\");\n  var doubleDelimiters = new RegExp(\"^((!=)|(\\\\+=)|(\\\\-=)|(\\\\*=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n  var tripleDelimiters = new RegExp(\"^((>>=)|(<<=))\");\n  var expressionEnd = new RegExp(\"^[\\\\]\\\\)]\");\n  var identifiers = new RegExp(\"^[_A-Za-z\\xa1-\\uffff][_A-Za-z0-9\\xa1-\\uffff]*\");\n\n  var builtins = wordRegexp([\n    'error', 'eval', 'function', 'abs', 'acos', 'atan', 'asin', 'cos',\n    'cosh', 'exp', 'log', 'prod', 'sum', 'log10', 'max', 'min', 'sign', 'sin', 'sinh',\n    'sqrt', 'tan', 'reshape', 'break', 'zeros', 'default', 'margin', 'round', 'ones',\n    'rand', 'syn', 'ceil', 'floor', 'size', 'clear', 'zeros', 'eye', 'mean', 'std', 'cov',\n    'det', 'eig', 'inv', 'norm', 'rank', 'trace', 'expm', 'logm', 'sqrtm', 'linspace', 'plot',\n    'title', 'xlabel', 'ylabel', 'legend', 'text', 'grid', 'meshgrid', 'mesh', 'num2str',\n    'fft', 'ifft', 'arrayfun', 'cellfun', 'input', 'fliplr', 'flipud', 'ismember'\n  ]);\n\n  var keywords = wordRegexp([\n    'return', 'case', 'switch', 'else', 'elseif', 'end', 'endif', 'endfunction',\n    'if', 'otherwise', 'do', 'for', 'while', 'try', 'catch', 'classdef', 'properties', 'events',\n    'methods', 'global', 'persistent', 'endfor', 'endwhile', 'printf', 'sprintf', 'disp', 'until',\n    'continue', 'pkg'\n  ]);\n\n\n  // tokenizers\n  function tokenTranspose(stream, state) {\n    if (!stream.sol() && stream.peek() === '\\'') {\n      stream.next();\n      state.tokenize = tokenBase;\n      return 'operator';\n    }\n    state.tokenize = tokenBase;\n    return tokenBase(stream, state);\n  }\n\n\n  function tokenComment(stream, state) {\n    if (stream.match(/^.*%}/)) {\n      state.tokenize = tokenBase;\n      return 'comment';\n    };\n    stream.skipToEnd();\n    return 'comment';\n  }\n\n  function tokenBase(stream, state) {\n    // whitespaces\n    if (stream.eatSpace()) return null;\n\n    // Handle one line Comments\n    if (stream.match('%{')){\n      state.tokenize = tokenComment;\n      stream.skipToEnd();\n      return 'comment';\n    }\n\n    if (stream.match(/^[%#]/)){\n      stream.skipToEnd();\n      return 'comment';\n    }\n\n    // Handle Number Literals\n    if (stream.match(/^[0-9\\.+-]/, false)) {\n      if (stream.match(/^[+-]?0x[0-9a-fA-F]+[ij]?/)) {\n        stream.tokenize = tokenBase;\n        return 'number'; };\n      if (stream.match(/^[+-]?\\d*\\.\\d+([EeDd][+-]?\\d+)?[ij]?/)) { return 'number'; };\n      if (stream.match(/^[+-]?\\d+([EeDd][+-]?\\d+)?[ij]?/)) { return 'number'; };\n    }\n    if (stream.match(wordRegexp(['nan','NaN','inf','Inf']))) { return 'number'; };\n\n    // Handle Strings\n    if (stream.match(/^\"([^\"]|(\"\"))*\"/)) { return 'string'; } ;\n    if (stream.match(/^'([^']|(''))*'/)) { return 'string'; } ;\n\n    // Handle words\n    if (stream.match(keywords)) { return 'keyword'; } ;\n    if (stream.match(builtins)) { return 'builtin'; } ;\n    if (stream.match(identifiers)) { return 'variable'; } ;\n\n    if (stream.match(singleOperators) || stream.match(doubleOperators)) { return 'operator'; };\n    if (stream.match(singleDelimiters) || stream.match(doubleDelimiters) || stream.match(tripleDelimiters)) { return null; };\n\n    if (stream.match(expressionEnd)) {\n      state.tokenize = tokenTranspose;\n      return null;\n    };\n\n\n    // Handle non-detected items\n    stream.next();\n    return 'error';\n  };\n\n\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase\n      };\n    },\n\n    token: function(stream, state) {\n      var style = state.tokenize(stream, state);\n      if (style === 'number' || style === 'variable'){\n        state.tokenize = tokenTranspose;\n      }\n      return style;\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-octave\", \"octave\");\n\n});\n"]}