{"version":3,"sources":["mode/r/r.js"],"names":["define","CodeMirror","registerHelper","defineMode","config","wordObj","str","words","split","res","i","length","tokenBase","stream","state","curPunc","ch","next","skipToEnd","eat","eatWhile","match","test","tokenize","tokenString","word","current","atoms","propertyIsEnumerable","keywords","blockkeywords","builtins","skipTo","ctx","argList","opChars","quote","backUp","push","type","indent","align","column","prev","pop","startState","indentUnit","afterIdent","token","sol","indentation","eatSpace","style","ctype","textAfter","firstChar","charAt","closing","lineComment","defineMIME"],"mappings":"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","file":"../../../mode/r/r.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.registerHelper(\"wordChars\", \"r\", /[\\w.]/);\n\nCodeMirror.defineMode(\"r\", function(config) {\n  function wordObj(str) {\n    var words = str.split(\" \"), res = {};\n    for (var i = 0; i < words.length; ++i) res[words[i]] = true;\n    return res;\n  }\n  var atoms = wordObj(\"NULL NA Inf NaN NA_integer_ NA_real_ NA_complex_ NA_character_\");\n  var builtins = wordObj(\"list quote bquote eval return call parse deparse\");\n  var keywords = wordObj(\"if else repeat while function for in next break\");\n  var blockkeywords = wordObj(\"if else repeat while function for\");\n  var opChars = /[+\\-*\\/^<>=!&|~$:]/;\n  var curPunc;\n\n  function tokenBase(stream, state) {\n    curPunc = null;\n    var ch = stream.next();\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"0\" && stream.eat(\"x\")) {\n      stream.eatWhile(/[\\da-f]/i);\n      return \"number\";\n    } else if (ch == \".\" && stream.eat(/\\d/)) {\n      stream.match(/\\d*(?:e[+\\-]?\\d+)?/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/\\d*(?:\\.\\d+)?(?:e[+\\-]\\d+)?L?/);\n      return \"number\";\n    } else if (ch == \"'\" || ch == '\"') {\n      state.tokenize = tokenString(ch);\n      return \"string\";\n    } else if (ch == \".\" && stream.match(/.[.\\d]+/)) {\n      return \"keyword\";\n    } else if (/[\\w\\.]/.test(ch) && ch != \"_\") {\n      stream.eatWhile(/[\\w\\.]/);\n      var word = stream.current();\n      if (atoms.propertyIsEnumerable(word)) return \"atom\";\n      if (keywords.propertyIsEnumerable(word)) {\n        // Block keywords start new blocks, except 'else if', which only starts\n        // one new block for the 'if', no block for the 'else'.\n        if (blockkeywords.propertyIsEnumerable(word) &&\n            !stream.match(/\\s*if(\\s+|$)/, false))\n          curPunc = \"block\";\n        return \"keyword\";\n      }\n      if (builtins.propertyIsEnumerable(word)) return \"builtin\";\n      return \"variable\";\n    } else if (ch == \"%\") {\n      if (stream.skipTo(\"%\")) stream.next();\n      return \"variable-2\";\n    } else if (ch == \"<\" && stream.eat(\"-\")) {\n      return \"arrow\";\n    } else if (ch == \"=\" && state.ctx.argList) {\n      return \"arg-is\";\n    } else if (opChars.test(ch)) {\n      if (ch == \"$\") return \"dollar\";\n      stream.eatWhile(opChars);\n      return \"operator\";\n    } else if (/[\\(\\){}\\[\\];]/.test(ch)) {\n      curPunc = ch;\n      if (ch == \";\") return \"semi\";\n      return null;\n    } else {\n      return null;\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      if (stream.eat(\"\\\\\")) {\n        var ch = stream.next();\n        if (ch == \"x\") stream.match(/^[a-f0-9]{2}/i);\n        else if ((ch == \"u\" || ch == \"U\") && stream.eat(\"{\") && stream.skipTo(\"}\")) stream.next();\n        else if (ch == \"u\") stream.match(/^[a-f0-9]{4}/i);\n        else if (ch == \"U\") stream.match(/^[a-f0-9]{8}/i);\n        else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);\n        return \"string-2\";\n      } else {\n        var next;\n        while ((next = stream.next()) != null) {\n          if (next == quote) { state.tokenize = tokenBase; break; }\n          if (next == \"\\\\\") { stream.backUp(1); break; }\n        }\n        return \"string\";\n      }\n    };\n  }\n\n  function push(state, type, stream) {\n    state.ctx = {type: type,\n                 indent: state.indent,\n                 align: null,\n                 column: stream.column(),\n                 prev: state.ctx};\n  }\n  function pop(state) {\n    state.indent = state.ctx.indent;\n    state.ctx = state.ctx.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase,\n              ctx: {type: \"top\",\n                    indent: -config.indentUnit,\n                    align: false},\n              indent: 0,\n              afterIdent: false};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (state.ctx.align == null) state.ctx.align = false;\n        state.indent = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (style != \"comment\" && state.ctx.align == null) state.ctx.align = true;\n\n      var ctype = state.ctx.type;\n      if ((curPunc == \";\" || curPunc == \"{\" || curPunc == \"}\") && ctype == \"block\") pop(state);\n      if (curPunc == \"{\") push(state, \"}\", stream);\n      else if (curPunc == \"(\") {\n        push(state, \")\", stream);\n        if (state.afterIdent) state.ctx.argList = true;\n      }\n      else if (curPunc == \"[\") push(state, \"]\", stream);\n      else if (curPunc == \"block\") push(state, \"block\", stream);\n      else if (curPunc == ctype) pop(state);\n      state.afterIdent = style == \"variable\" || style == \"keyword\";\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,\n          closing = firstChar == ctx.type;\n      if (ctx.type == \"block\") return ctx.indent + (firstChar == \"{\" ? 0 : config.indentUnit);\n      else if (ctx.align) return ctx.column + (closing ? 0 : 1);\n      else return ctx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-rsrc\", \"r\");\n\n});\n"]}