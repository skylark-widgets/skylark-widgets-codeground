{"version":3,"sources":["mode/smarty/smarty.js"],"names":["define","CodeMirror","defineMode","config","parserConf","cont","style","lastType","last","chain","stream","state","parser","tokenize","doesNotCount","pos","version","leftDelimiter","string","length","test","charAt","tokenTop","scan","nextMatch","indexOf","match","eat","tokenBlock","rightDelimiter","depth","tokenSmarty","slice","token","baseMode","base","ch","next","eatWhile","regs","validIdentifier","stringChar","tokenAttribute","operatorChars","str","c","i","j","keyFunctions","quote","prevChar","currChar","eol","peek","terminator","getMode","startState","copyState","innerMode","mode","indent","text","Pass","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"../../../mode/smarty/smarty.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function(config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n\n    var last;\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" &&\n        (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    }\n\n    // parsing Smarty content\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        } if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n        if (ch != \"/\") {\n          str += ch;\n        }\n        var c = null;\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n        for (var i=0, j=keyFunctions.length; i<j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function(stream, state) {\n        var prevChar = null;\n        var currChar = null;\n        while (!stream.eol()) {\n          currChar = stream.peek();\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n          prevChar = currChar;\n        }\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n\n    return {\n      startState: function() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function(state) {\n        if (state.tokenize == tokenTop)\n          return {mode: baseMode, state: state.base};\n      },\n      token: function(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function(state, text) {\n        if (state.tokenize == tokenTop && baseMode.indent)\n          return baseMode.indent(state.base, text);\n        else\n          return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});\n"]}