{"version":3,"sources":["mode/swift/swift.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","wordSet","words","set","i","length","tokenBase","stream","state","prev","sol","indented","indentation","eatSpace","ch","peek","match","skipToEnd","tokenize","push","tokenComment","regexp","operators","indexOf","next","punc","tokenString","number","property","identifier","ident","current","keywords","hasOwnProperty","definingKeywords","types","atoms","tokenUntilClosingParen","depth","inner","backUp","pop","quote","escaped","Context","align","this","pushContext","column","context","popContext","defineMode","config","startState","token","style","bracket","exec","indent","textAfter","cx","closing","test","indentUnit","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","file":"../../../mode/swift/swift.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// Swift mode created by Michael Kaminsky https://github.com/mkaminsky11\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    mod(require(\"../../Coder\"))\n  else if (typeof define == \"function\" && define.amd)\n    define([\"../../Coder\"], mod)\n  else\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  function wordSet(words) {\n    var set = {}\n    for (var i = 0; i < words.length; i++) set[words[i]] = true\n    return set\n  }\n\n  var keywords = wordSet([\"var\",\"let\",\"class\",\"deinit\",\"enum\",\"extension\",\"func\",\"import\",\"init\",\"protocol\",\n                          \"static\",\"struct\",\"subscript\",\"typealias\",\"as\",\"dynamicType\",\"is\",\"new\",\"super\",\n                          \"self\",\"Self\",\"Type\",\"__COLUMN__\",\"__FILE__\",\"__FUNCTION__\",\"__LINE__\",\"break\",\"case\",\n                          \"continue\",\"default\",\"do\",\"else\",\"fallthrough\",\"if\",\"in\",\"for\",\"return\",\"switch\",\n                          \"where\",\"while\",\"associativity\",\"didSet\",\"get\",\"infix\",\"inout\",\"left\",\"mutating\",\n                          \"none\",\"nonmutating\",\"operator\",\"override\",\"postfix\",\"precedence\",\"prefix\",\"right\",\n                          \"set\",\"unowned\",\"weak\",\"willSet\"])\n  var definingKeywords = wordSet([\"var\",\"let\",\"class\",\"enum\",\"extension\",\"func\",\"import\",\"protocol\",\"struct\",\n                                  \"typealias\",\"dynamicType\",\"for\"])\n  var atoms = wordSet([\"Infinity\",\"NaN\",\"undefined\",\"null\",\"true\",\"false\",\"on\",\"off\",\"yes\",\"no\",\"nil\",\"null\",\n                       \"this\",\"super\"])\n  var types = wordSet([\"String\",\"bool\",\"int\",\"string\",\"double\",\"Double\",\"Int\",\"Float\",\"float\",\"public\",\n                       \"private\",\"extension\"])\n  var operators = \"+-/*%=|&<>#\"\n  var punc = \";,.(){}[]\"\n  var number = /^-?(?:(?:[\\d_]+\\.[_\\d]*|\\.[_\\d]+|0o[0-7_\\.]+|0b[01_\\.]+)(?:e-?[\\d_]+)?|0x[\\d_a-f\\.]+(?:p-?[\\d_]+)?)/i\n  var identifier = /^[_A-Za-z$][_A-Za-z$0-9]*/\n  var property = /^[@\\.][_A-Za-z$][_A-Za-z$0-9]*/\n  var regexp = /^\\/(?!\\s)(?:\\/\\/)?(?:\\\\.|[^\\/])+\\//\n\n  function tokenBase(stream, state, prev) {\n    if (stream.sol()) state.indented = stream.indentation()\n    if (stream.eatSpace()) return null\n\n    var ch = stream.peek()\n    if (ch == \"/\") {\n      if (stream.match(\"//\")) {\n        stream.skipToEnd()\n        return \"comment\"\n      }\n      if (stream.match(\"/*\")) {\n        state.tokenize.push(tokenComment)\n        return tokenComment(stream, state)\n      }\n      if (stream.match(regexp)) return \"string-2\"\n    }\n    if (operators.indexOf(ch) > -1) {\n      stream.next()\n      return \"operator\"\n    }\n    if (punc.indexOf(ch) > -1) {\n      stream.next()\n      stream.match(\"..\")\n      return \"punctuation\"\n    }\n    if (ch == '\"' || ch == \"'\") {\n      stream.next()\n      var tokenize = tokenString(ch)\n      state.tokenize.push(tokenize)\n      return tokenize(stream, state)\n    }\n\n    if (stream.match(number)) return \"number\"\n    if (stream.match(property)) return \"property\"\n\n    if (stream.match(identifier)) {\n      var ident = stream.current()\n      if (keywords.hasOwnProperty(ident)) {\n        if (definingKeywords.hasOwnProperty(ident))\n          state.prev = \"define\"\n        return \"keyword\"\n      }\n      if (types.hasOwnProperty(ident)) return \"variable-2\"\n      if (atoms.hasOwnProperty(ident)) return \"atom\"\n      if (prev == \"define\") return \"def\"\n      return \"variable\"\n    }\n\n    stream.next()\n    return null\n  }\n\n  function tokenUntilClosingParen() {\n    var depth = 0\n    return function(stream, state, prev) {\n      var inner = tokenBase(stream, state, prev)\n      if (inner == \"punctuation\") {\n        if (stream.current() == \"(\") ++depth\n        else if (stream.current() == \")\") {\n          if (depth == 0) {\n            stream.backUp(1)\n            state.tokenize.pop()\n            return state.tokenize[state.tokenize.length - 1](stream, state)\n          }\n          else --depth\n        }\n      }\n      return inner\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var ch, escaped = false\n      while (ch = stream.next()) {\n        if (escaped) {\n          if (ch == \"(\") {\n            state.tokenize.push(tokenUntilClosingParen())\n            return \"string\"\n          }\n          escaped = false\n        } else if (ch == quote) {\n          break\n        } else {\n          escaped = ch == \"\\\\\"\n        }\n      }\n      state.tokenize.pop()\n      return \"string\"\n    }\n  }\n\n  function tokenComment(stream, state) {\n    stream.match(/^(?:[^*]|\\*(?!\\/))*/)\n    if (stream.match(\"*/\")) state.tokenize.pop()\n    return \"comment\"\n  }\n\n  function Context(prev, align, indented) {\n    this.prev = prev\n    this.align = align\n    this.indented = indented\n  }\n\n  function pushContext(state, stream) {\n    var align = stream.match(/^\\s*($|\\/[\\/\\*])/, false) ? null : stream.column() + 1\n    state.context = new Context(state.context, align, state.indented)\n  }\n\n  function popContext(state) {\n    if (state.context) {\n      state.indented = state.context.indented\n      state.context = state.context.prev\n    }\n  }\n\n  CodeMirror.defineMode(\"swift\", function(config) {\n    return {\n      startState: function() {\n        return {\n          prev: null,\n          context: null,\n          indented: 0,\n          tokenize: []\n        }\n      },\n\n      token: function(stream, state) {\n        var prev = state.prev\n        state.prev = null\n        var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase\n        var style = tokenize(stream, state, prev)\n        if (!style || style == \"comment\") state.prev = prev\n        else if (!state.prev) state.prev = style\n\n        if (style == \"punctuation\") {\n          var bracket = /[\\(\\[\\{]|([\\]\\)\\}])/.exec(stream.current())\n          if (bracket) (bracket[1] ? popContext : pushContext)(state, stream)\n        }\n\n        return style\n      },\n\n      indent: function(state, textAfter) {\n        var cx = state.context\n        if (!cx) return 0\n        var closing = /^[\\]\\}\\)]/.test(textAfter)\n        if (cx.align != null) return cx.align - (closing ? 1 : 0)\n        return cx.indented + (closing ? 0 : config.indentUnit)\n      },\n\n      electricInput: /^\\s*[\\)\\}\\]]$/,\n\n      lineComment: \"//\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\"\n    }\n  })\n\n  CodeMirror.defineMIME(\"text/x-swift\",\"swift\")\n});\n"]}