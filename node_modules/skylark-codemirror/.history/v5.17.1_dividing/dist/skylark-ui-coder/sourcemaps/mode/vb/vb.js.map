{"version":3,"sources":["mode/vb/vb.js"],"names":["define","CodeMirror","defineMode","conf","parserConf","wordRegexp","words","RegExp","join","indent","_stream","state","currentIndent","dedent","tokenBase","stream","eatSpace","ch","peek","skipToEnd","match","floatLiteral","eat","intLiteral","stringPrefixes","tokenize","tokenStringFactory","current","tripleDelimiters","doubleDelimiters","doubleOperators","singleOperators","wordOperators","singleDelimiters","doOpening","doInCurrentLine","opening","middle","doubleClosing","closing","types","keywords","identifiers","next","ERRORCLASS","delimiter","singleline","length","OUTCLASS","eol","eatWhile","singleLineStringErrors","tokenLexer","style","delimiter_index","indexOf","indentInfo","openingKeywords","middleKeywords","endKeywords","operatorKeywords","commonKeywords","commontypes","registerHelper","concat","external","electricChars","startState","lastToken","nextLineIndent","token","sol","content","textAfter","trueText","replace","indentUnit","lineComment","defineMIME"],"mappings":"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","file":"../../../mode/vb/vb.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"vb\", function(conf, parserConf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n        return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&\\\\\\\\|\\\\^~<>!]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}@,:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\\\*\\\\*))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z][_A-Za-z0-9]*\");\n\n    var openingKeywords = ['class','module', 'sub','enum','select','while','if','function',  'get','set','property', 'try'];\n    var middleKeywords = ['else','elseif','case', 'catch'];\n    var endKeywords = ['next','loop'];\n\n    var operatorKeywords = ['and', 'or', 'not', 'xor', 'in'];\n    var wordOperators = wordRegexp(operatorKeywords);\n    var commonKeywords = ['as', 'dim', 'break',  'continue','optional', 'then',  'until',\n                          'goto', 'byval','byref','new','handles','property', 'return',\n                          'const','private', 'protected', 'friend', 'public', 'shared', 'static', 'true','false'];\n    var commontypes = ['integer','string','double','decimal','boolean','short','char', 'float','single'];\n\n    var keywords = wordRegexp(commonKeywords);\n    var types = wordRegexp(commontypes);\n    var stringPrefixes = '\"';\n\n    var opening = wordRegexp(openingKeywords);\n    var middle = wordRegexp(middleKeywords);\n    var closing = wordRegexp(endKeywords);\n    var doubleClosing = wordRegexp(['end']);\n    var doOpening = wordRegexp(['do']);\n\n    var indentInfo = null;\n\n    CodeMirror.registerHelper(\"hintWords\", \"vb\", openingKeywords.concat(middleKeywords).concat(endKeywords)\n                                .concat(operatorKeywords).concat(commonKeywords).concat(commontypes));\n\n    function indent(_stream, state) {\n      state.currentIndent++;\n    }\n\n    function dedent(_stream, state) {\n      state.currentIndent--;\n    }\n    // tokenizers\n    function tokenBase(stream, state) {\n        if (stream.eatSpace()) {\n            return null;\n        }\n\n        var ch = stream.peek();\n\n        // Handle Comments\n        if (ch === \"'\") {\n            stream.skipToEnd();\n            return 'comment';\n        }\n\n\n        // Handle Number Literals\n        if (stream.match(/^((&H)|(&O))?[0-9\\.a-f]/i, false)) {\n            var floatLiteral = false;\n            // Floats\n            if (stream.match(/^\\d*\\.\\d+F?/i)) { floatLiteral = true; }\n            else if (stream.match(/^\\d+\\.\\d*F?/)) { floatLiteral = true; }\n            else if (stream.match(/^\\.\\d+F?/)) { floatLiteral = true; }\n\n            if (floatLiteral) {\n                // Float literals may be \"imaginary\"\n                stream.eat(/J/i);\n                return 'number';\n            }\n            // Integers\n            var intLiteral = false;\n            // Hex\n            if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }\n            // Octal\n            else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }\n            // Decimal\n            else if (stream.match(/^[1-9]\\d*F?/)) {\n                // Decimal literals may be \"imaginary\"\n                stream.eat(/J/i);\n                // TODO - Can you have imaginary longs?\n                intLiteral = true;\n            }\n            // Zero by itself with no other piece of number.\n            else if (stream.match(/^0(?![\\dx])/i)) { intLiteral = true; }\n            if (intLiteral) {\n                // Integer literals may be \"long\"\n                stream.eat(/L/i);\n                return 'number';\n            }\n        }\n\n        // Handle Strings\n        if (stream.match(stringPrefixes)) {\n            state.tokenize = tokenStringFactory(stream.current());\n            return state.tokenize(stream, state);\n        }\n\n        // Handle operators and Delimiters\n        if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doubleOperators)\n            || stream.match(singleOperators)\n            || stream.match(wordOperators)) {\n            return 'operator';\n        }\n        if (stream.match(singleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doOpening)) {\n            indent(stream,state);\n            state.doInCurrentLine = true;\n            return 'keyword';\n        }\n        if (stream.match(opening)) {\n            if (! state.doInCurrentLine)\n              indent(stream,state);\n            else\n              state.doInCurrentLine = false;\n            return 'keyword';\n        }\n        if (stream.match(middle)) {\n            return 'keyword';\n        }\n\n        if (stream.match(doubleClosing)) {\n            dedent(stream,state);\n            dedent(stream,state);\n            return 'keyword';\n        }\n        if (stream.match(closing)) {\n            dedent(stream,state);\n            return 'keyword';\n        }\n\n        if (stream.match(types)) {\n            return 'keyword';\n        }\n\n        if (stream.match(keywords)) {\n            return 'keyword';\n        }\n\n        if (stream.match(identifiers)) {\n            return 'variable';\n        }\n\n        // Handle non-detected items\n        stream.next();\n        return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n        var singleline = delimiter.length == 1;\n        var OUTCLASS = 'string';\n\n        return function(stream, state) {\n            while (!stream.eol()) {\n                stream.eatWhile(/[^'\"]/);\n                if (stream.match(delimiter)) {\n                    state.tokenize = tokenBase;\n                    return OUTCLASS;\n                } else {\n                    stream.eat(/['\"]/);\n                }\n            }\n            if (singleline) {\n                if (parserConf.singleLineStringErrors) {\n                    return ERRORCLASS;\n                } else {\n                    state.tokenize = tokenBase;\n                }\n            }\n            return OUTCLASS;\n        };\n    }\n\n\n    function tokenLexer(stream, state) {\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n\n        // Handle '.' connected identifiers\n        if (current === '.') {\n            style = state.tokenize(stream, state);\n            current = stream.current();\n            if (style === 'variable') {\n                return 'variable';\n            } else {\n                return ERRORCLASS;\n            }\n        }\n\n\n        var delimiter_index = '[({'.indexOf(current);\n        if (delimiter_index !== -1) {\n            indent(stream, state );\n        }\n        if (indentInfo === 'dedent') {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n        delimiter_index = '])}'.indexOf(current);\n        if (delimiter_index !== -1) {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n\n        return style;\n    }\n\n    var external = {\n        electricChars:\"dDpPtTfFeE \",\n        startState: function() {\n            return {\n              tokenize: tokenBase,\n              lastToken: null,\n              currentIndent: 0,\n              nextLineIndent: 0,\n              doInCurrentLine: false\n\n\n          };\n        },\n\n        token: function(stream, state) {\n            if (stream.sol()) {\n              state.currentIndent += state.nextLineIndent;\n              state.nextLineIndent = 0;\n              state.doInCurrentLine = 0;\n            }\n            var style = tokenLexer(stream, state);\n\n            state.lastToken = {style:style, content: stream.current()};\n\n\n\n            return style;\n        },\n\n        indent: function(state, textAfter) {\n            var trueText = textAfter.replace(/^\\s+|\\s+$/g, '') ;\n            if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);\n            if(state.currentIndent < 0) return 0;\n            return state.currentIndent * conf.indentUnit;\n        },\n\n        lineComment: \"'\"\n    };\n    return external;\n});\n\nCodeMirror.defineMIME(\"text/x-vb\", \"vb\");\n\n});\n"]}