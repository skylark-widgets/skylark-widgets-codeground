{"version":3,"sources":["mode/verilog/verilog.js"],"names":["define","CodeMirror","tlvGenIndent","stream","state","tlvindentUnit","rtnIndent","indentUnitRq","curIndent","indentation","tlvCurCtlFlowChar","tlvPrevPrevCtlFlowChar","tlvchScopePrefixes","tlvPrevCtlFlowChar","statementIndentUnit","defineMode","config","parserConfig","words","str","obj","split","i","length","tokenBase","style","ch","peek","hooks","test","curPunc","next","isBracketChar","eatWhile","tokenize","tokenString","eat","tokenComment","skipToEnd","backUp","match","realLiteral","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","unsignedNumber","isOperatorChar","cur","current","keywords","openClose","statementKeywords","curKeyword","quote","escaped","end","multiLineStrings","maybeEnd","Context","indented","column","type","align","prev","this","pushContext","col","indent","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","buildElectricInputRegEx","allClosings","closings","j","push","re","RegExp","join","indentUnit","dontAlignCalls","noIndentKeywords","closingBracketOrWord","closingBracket","blockKeywords","keyword","undefined","electricInput","startState","basecolumn","startOfLine","token","ctx","sol","eatSpace","close","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","defineMIME","name",">","->","-","|","?$","?*","@-","@","?","\\","vxIndent","string","vxCodeActive","vxIndentRq","tlvisOperatorChar","tlvkpScopePrefixs","**","*","$$","$","^^","^","vxCurCtlFlowCharValueAtStart","skipTo","propertyIsEnumerable"],"mappings":"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","file":"../../../mode/verilog/verilog.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\ndefine([\"../../Coder\"], function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"verilog\", function(config, parserConfig) {\n\n  var indentUnit = config.indentUnit,\n      statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n      dontAlignCalls = parserConfig.dontAlignCalls,\n      noIndentKeywords = parserConfig.noIndentKeywords || [],\n      multiLineStrings = parserConfig.multiLineStrings,\n      hooks = parserConfig.hooks || {};\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  /**\n   * Keywords from IEEE 1800-2012\n   */\n  var keywords = words(\n    \"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" +\n    \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" +\n    \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" +\n    \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" +\n    \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" +\n    \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" +\n    \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" +\n    \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" +\n    \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" +\n    \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" +\n    \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" +\n    \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" +\n    \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" +\n    \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" +\n    \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" +\n    \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" +\n    \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" +\n    \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n\n  /** Operators from IEEE 1800-2012\n     unary_operator ::=\n       + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_operator ::=\n       + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n       | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n       | -> | <->\n     inc_or_dec_operator ::= ++ | --\n     unary_module_path_operator ::=\n       ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n     binary_module_path_operator ::=\n       == | != | && | || | & | | | ^ | ^~ | ~^\n  */\n  var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:]/;\n  var isBracketChar = /[\\[\\]{}()]/;\n\n  var unsignedNumber = /\\d[0-9_]*/;\n  var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n  var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n  var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n  var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n  var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n\n  var closingBracketOrWord = /^((\\w+)|[)}\\]])/;\n  var closingBracket = /[)}\\]]/;\n\n  var curPunc;\n  var curKeyword;\n\n  // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n  // E.g. \"task\" => \"endtask\"\n  var blockKeywords = words(\n    \"case checker class clocking config function generate interface module package\" +\n    \"primitive program property specify sequence table task\"\n  );\n\n  // Opening/closing pairs\n  var openClose = {};\n  for (var keyword in blockKeywords) {\n    openClose[keyword] = \"end\" + keyword;\n  }\n  openClose[\"begin\"] = \"end\";\n  openClose[\"casex\"] = \"endcase\";\n  openClose[\"casez\"] = \"endcase\";\n  openClose[\"do\"   ] = \"while\";\n  openClose[\"fork\" ] = \"join;join_any;join_none\";\n  openClose[\"covergroup\"] = \"endgroup\";\n\n  for (var i in noIndentKeywords) {\n    var keyword = noIndentKeywords[i];\n    if (openClose[keyword]) {\n      openClose[keyword] = undefined;\n    }\n  }\n\n  // Keywords which open statements that are ended with a semi-colon\n  var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while\");\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek(), style;\n    if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n    if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false)\n      return style;\n\n    if (/[,;:\\.]/.test(ch)) {\n      curPunc = stream.next();\n      return null;\n    }\n    if (isBracketChar.test(ch)) {\n      curPunc = stream.next();\n      return \"bracket\";\n    }\n    // Macros (tick-defines)\n    if (ch == '`') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"def\";\n      } else {\n        return null;\n      }\n    }\n    // System calls\n    if (ch == '$') {\n      stream.next();\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        return \"meta\";\n      } else {\n        return null;\n      }\n    }\n    // Time literals\n    if (ch == '#') {\n      stream.next();\n      stream.eatWhile(/[\\d_.]/);\n      return \"def\";\n    }\n    // Strings\n    if (ch == '\"') {\n      stream.next();\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    // Comments\n    if (ch == \"/\") {\n      stream.next();\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      stream.backUp(1);\n    }\n\n    // Numeric literals\n    if (stream.match(realLiteral) ||\n        stream.match(decimalLiteral) ||\n        stream.match(binaryLiteral) ||\n        stream.match(octLiteral) ||\n        stream.match(hexLiteral) ||\n        stream.match(unsignedNumber) ||\n        stream.match(realLiteral)) {\n      return \"number\";\n    }\n\n    // Operators\n    if (stream.eatWhile(isOperatorChar)) {\n      return \"meta\";\n    }\n\n    // Keywords / plain variables\n    if (stream.eatWhile(/[\\w\\$_]/)) {\n      var cur = stream.current();\n      if (keywords[cur]) {\n        if (openClose[cur]) {\n          curPunc = \"newblock\";\n        }\n        if (statementKeywords[cur]) {\n          curPunc = \"newstatement\";\n        }\n        curKeyword = cur;\n        return \"keyword\";\n      }\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    var indent = state.indented;\n    var c = new Context(indent, col, type, null, state.context);\n    return state.context = c;\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\") {\n      state.indented = state.context.indented;\n    }\n    return state.context = state.context.prev;\n  }\n\n  function isClosing(text, contextClosing) {\n    if (text == contextClosing) {\n      return true;\n    } else {\n      // contextClosing may be multiple keywords separated by ;\n      var closingKeywords = contextClosing.split(\";\");\n      for (var i in closingKeywords) {\n        if (text == closingKeywords[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on any bracket char: {}()[]\n    // or on a match of any of the block closing keywords, at\n    // the end of a line\n    var allClosings = [];\n    for (var i in openClose) {\n      if (openClose[i]) {\n        var closings = openClose[i].split(\";\");\n        for (var j in closings) {\n          allClosings.push(closings[j]);\n        }\n      }\n    }\n    var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    return re;\n  }\n\n  // Interface\n  return {\n\n    // Regex to force current line to reindent\n    electricInput: buildElectricInputRegEx(),\n\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n      if (hooks.startState) hooks.startState(state);\n      return state;\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (hooks.token) hooks.token(stream, state);\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      curKeyword = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\" || style == \"variable\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if (curPunc == ctx.type) {\n        popContext(state);\n      } else if ((curPunc == \";\" && ctx.type == \"statement\") ||\n               (ctx.type && isClosing(curKeyword, ctx.type))) {\n        ctx = popContext(state);\n        while (ctx && ctx.type == \"statement\") ctx = popContext(state);\n      } else if (curPunc == \"{\") {\n        pushContext(state, stream.column(), \"}\");\n      } else if (curPunc == \"[\") {\n        pushContext(state, stream.column(), \"]\");\n      } else if (curPunc == \"(\") {\n        pushContext(state, stream.column(), \")\");\n      } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newstatement\") {\n        pushContext(state, stream.column(), \"statement\");\n      } else if (curPunc == \"newblock\") {\n        if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {\n          // The 'function' keyword can appear in some other contexts where it actually does not\n          // indicate a function (import/export DPI and covergroup definitions).\n          // Do nothing in this case\n        } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {\n          // Same thing for task\n        } else {\n          var close = openClose[curKeyword];\n          pushContext(state, stream.column(), close);\n        }\n      }\n\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n      if (hooks.indent) {\n        var fromHook = hooks.indent(state);\n        if (fromHook >= 0) return fromHook;\n      }\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = false;\n      var possibleClosing = textAfter.match(closingBracketOrWord);\n      if (possibleClosing)\n        closing = isClosing(possibleClosing[0], ctx.type);\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);\n      else if (closingBracket.test(ctx.type) && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);\n      else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  });\n\n  // TLVVerilog mode\n\n  var tlvchScopePrefixes = {\n    \">\": \"property\", \"->\": \"property\", \"-\": \"hr\", \"|\": \"link\", \"?$\": \"qualifier\", \"?*\": \"qualifier\",\n    \"@-\": \"variable-3\", \"@\": \"variable-3\", \"?\": \"qualifier\"\n  };\n\n  function tlvGenIndent(stream, state) {\n    var tlvindentUnit = 2;\n    var rtnIndent = -1, indentUnitRq = 0, curIndent = stream.indentation();\n    switch (state.tlvCurCtlFlowChar) {\n    case \"\\\\\":\n      curIndent = 0;\n      break;\n    case \"|\":\n      if (state.tlvPrevPrevCtlFlowChar == \"@\") {\n        indentUnitRq = -2; //-2 new pipe rq after cur pipe\n        break;\n      }\n      if (tlvchScopePrefixes[state.tlvPrevCtlFlowChar])\n        indentUnitRq = 1; // +1 new scope\n      break;\n    case \"M\":  // m4\n      if (state.tlvPrevPrevCtlFlowChar == \"@\") {\n        indentUnitRq = -2; //-2 new inst rq after  pipe\n        break;\n      }\n      if (tlvchScopePrefixes[state.tlvPrevCtlFlowChar])\n        indentUnitRq = 1; // +1 new scope\n      break;\n    case \"@\":\n      if (state.tlvPrevCtlFlowChar == \"S\")\n        indentUnitRq = -1; // new pipe stage after stmts\n      if (state.tlvPrevCtlFlowChar == \"|\")\n        indentUnitRq = 1; // 1st pipe stage\n      break;\n    case \"S\":\n      if (state.tlvPrevCtlFlowChar == \"@\")\n        indentUnitRq = 1; // flow in pipe stage\n      if (tlvchScopePrefixes[state.tlvPrevCtlFlowChar])\n        indentUnitRq = 1; // +1 new scope\n      break;\n    }\n    var statementIndentUnit = tlvindentUnit;\n    rtnIndent = curIndent + (indentUnitRq*statementIndentUnit);\n    return rtnIndent >= 0 ? rtnIndent : curIndent;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n    hooks: {\n      \"\\\\\": function(stream, state) {\n        var vxIndent = 0, style = false;\n        var curPunc  = stream.string;\n        if ((stream.sol()) && ((/\\\\SV/.test(stream.string)) || (/\\\\TLV/.test(stream.string)))) {\n          curPunc = (/\\\\TLV_version/.test(stream.string))\n            ? \"\\\\TLV_version\" : stream.string;\n          stream.skipToEnd();\n          if (curPunc == \"\\\\SV\" && state.vxCodeActive) {state.vxCodeActive = false;};\n          if ((/\\\\TLV/.test(curPunc) && !state.vxCodeActive)\n            || (curPunc==\"\\\\TLV_version\" && state.vxCodeActive)) {state.vxCodeActive = true;};\n          style = \"keyword\";\n          state.tlvCurCtlFlowChar  = state.tlvPrevPrevCtlFlowChar\n            = state.tlvPrevCtlFlowChar = \"\";\n          if (state.vxCodeActive == true) {\n            state.tlvCurCtlFlowChar  = \"\\\\\";\n            vxIndent = tlvGenIndent(stream, state);\n          }\n          state.vxIndentRq = vxIndent;\n        }\n        return style;\n      },\n      tokenBase: function(stream, state) {\n        var vxIndent = 0, style = false;\n        var tlvisOperatorChar = /[\\[\\]=:]/;\n        var tlvkpScopePrefixs = {\n          \"**\":\"variable-2\", \"*\":\"variable-2\", \"$$\":\"variable\", \"$\":\"variable\",\n          \"^^\":\"attribute\", \"^\":\"attribute\"};\n        var ch = stream.peek();\n        var vxCurCtlFlowCharValueAtStart = state.tlvCurCtlFlowChar;\n        if (state.vxCodeActive == true) {\n          if (/[\\[\\]{}\\(\\);\\:]/.test(ch)) {\n            // bypass nesting and 1 char punc\n            style = \"meta\";\n            stream.next();\n          } else if (ch == \"/\") {\n            stream.next();\n            if (stream.eat(\"/\")) {\n              stream.skipToEnd();\n              style = \"comment\";\n              state.tlvCurCtlFlowChar = \"S\";\n            } else {\n              stream.backUp(1);\n            }\n          } else if (ch == \"@\") {\n            // pipeline stage\n            style = tlvchScopePrefixes[ch];\n            state.tlvCurCtlFlowChar = \"@\";\n            stream.next();\n            stream.eatWhile(/[\\w\\$_]/);\n          } else if (stream.match(/\\b[mM]4+/, true)) { // match: function(pattern, consume, caseInsensitive)\n            // m4 pre proc\n            stream.skipTo(\"(\");\n            style = \"def\";\n            state.tlvCurCtlFlowChar = \"M\";\n          } else if (ch == \"!\" && stream.sol()) {\n            // v stmt in tlv region\n            // state.tlvCurCtlFlowChar  = \"S\";\n            style = \"comment\";\n            stream.next();\n          } else if (tlvisOperatorChar.test(ch)) {\n            // operators\n            stream.eatWhile(tlvisOperatorChar);\n            style = \"operator\";\n          } else if (ch == \"#\") {\n            // phy hier\n            state.tlvCurCtlFlowChar  = (state.tlvCurCtlFlowChar == \"\")\n              ? ch : state.tlvCurCtlFlowChar;\n            stream.next();\n            stream.eatWhile(/[+-]\\d/);\n            style = \"tag\";\n          } else if (tlvkpScopePrefixs.propertyIsEnumerable(ch)) {\n            // special TLV operators\n            style = tlvkpScopePrefixs[ch];\n            state.tlvCurCtlFlowChar = state.tlvCurCtlFlowChar == \"\" ? \"S\" : state.tlvCurCtlFlowChar;  // stmt\n            stream.next();\n            stream.match(/[a-zA-Z_0-9]+/);\n          } else if (style = tlvchScopePrefixes[ch] || false) {\n            // special TLV operators\n            state.tlvCurCtlFlowChar = state.tlvCurCtlFlowChar == \"\" ? ch : state.tlvCurCtlFlowChar;\n            stream.next();\n            stream.match(/[a-zA-Z_0-9]+/);\n          }\n          if (state.tlvCurCtlFlowChar != vxCurCtlFlowCharValueAtStart) { // flow change\n            vxIndent = tlvGenIndent(stream, state);\n            state.vxIndentRq = vxIndent;\n          }\n        }\n        return style;\n      },\n      token: function(stream, state) {\n        if (state.vxCodeActive == true && stream.sol() && state.tlvCurCtlFlowChar != \"\") {\n          state.tlvPrevPrevCtlFlowChar = state.tlvPrevCtlFlowChar;\n          state.tlvPrevCtlFlowChar = state.tlvCurCtlFlowChar;\n          state.tlvCurCtlFlowChar = \"\";\n        }\n      },\n      indent: function(state) {\n        return (state.vxCodeActive == true) ? state.vxIndentRq : -1;\n      },\n      startState: function(state) {\n        state.tlvCurCtlFlowChar = \"\";\n        state.tlvPrevCtlFlowChar = \"\";\n        state.tlvPrevPrevCtlFlowChar = \"\";\n        state.vxCodeActive = true;\n        state.vxIndentRq = 0;\n      }\n    }\n  });\n});\n"]}