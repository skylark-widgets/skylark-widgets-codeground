{"version":3,"sources":["primitives/display/scroll_events.js"],"names":["define","browser","CoderCtor","partial","setScrollTop","val","cm","this","Math","abs","doc","scrollTop","gecko","updateDisplaySimple","top","display","scroller","scrollbars","startWorker","setScrollLeft","isScroller","scrollLeft","min","scrollWidth","clientWidth","alignHorizontally","onScrollWheel","e","delta","wheelEventDelta","dx","x","dy","y","scroll","canScrollX","canScrollY","scrollHeight","clientHeight","mac","webkit","outer","cur","target","view","parentNode","i","length","node","currentWheelTarget","presto","wheelPixelsPerUnit","max","e_preventDefault","wheelStartX","pixels","bot","wrapper","height","bottom","wheelSamples","wheelStartY","wheelDX","wheelDY","setTimeout","movedX","movedY","sample","ie","chrome","safari","wheelDeltaX","wheelDeltaY","detail","axis","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","CodeMirror","wheelEventPixels"],"mappings":"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","file":"../../../primitives/display/scroll_events.js","sourcesContent":["define([\r\n  \"../util/browser\",\r\n  \"../CoderCtor\"\r\n],function(browser,CoderCtor) {\r\n  // SCROLL EVENTS\r\n\r\n  CoderCtor.partial({\r\n    // Sync the scrollable area and scrollbars, ensure the viewport\r\n    // covers the visible area.\r\n    setScrollTop : function (val) {\r\n      var cm = this;\r\n\r\n      if (Math.abs(cm.doc.scrollTop - val) < 2) {\r\n        return;\r\n      }\r\n      cm.doc.scrollTop = val;\r\n      \r\n      if (!browser.gecko) {\r\n        cm.updateDisplaySimple({top: val});\r\n      }\r\n      if (cm.display.scroller.scrollTop != val) {\r\n        cm.display.scroller.scrollTop = val;\r\n      }\r\n      cm.display.scrollbars.setScrollTop(val);\r\n      if (browser.gecko) {\r\n        cm.updateDisplaySimple();\r\n      }\r\n      cm.startWorker(100);\r\n    },\r\n\r\n    // Sync scroller and scrollbar, ensure the gutter elements are\r\n    // aligned.\r\n    setScrollLeft : function (val, isScroller) {\r\n      var cm = this;\r\n\r\n      if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) {\r\n        return;\r\n      }\r\n      val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n      \r\n      cm.doc.scrollLeft = val;\r\n      \r\n      cm.alignHorizontally();\r\n\r\n      if (cm.display.scroller.scrollLeft != val) {\r\n        cm.display.scroller.scrollLeft = val;\r\n      }\r\n      cm.display.scrollbars.setScrollLeft(val);\r\n    },\r\n\r\n    onScrollWheel : function (e) {\r\n      var cm = this;\r\n\r\n      var delta = wheelEventDelta(e), \r\n        dx = delta.x, dy = delta.y;\r\n\r\n      var display = cm.display, scroll = display.scroller;\r\n      // Quit if there's nothing to scroll here\r\n      var canScrollX = scroll.scrollWidth > scroll.clientWidth;\r\n      var canScrollY = scroll.scrollHeight > scroll.clientHeight;\r\n      if (!(dx && canScrollX || dy && canScrollY)) return;\r\n\r\n      // Webkit browsers on OS X abort momentum scrolls when the target\r\n      // of the scroll event is removed from the scrollable element.\r\n      // This hack (see related code in patchDisplay) makes sure the\r\n      // element is kept around.\r\n      if (dy && mac && webkit) {\r\n        outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n          for (var i = 0; i < view.length; i++) {\r\n            if (view[i].node == cur) {\r\n              cm.display.currentWheelTarget = cur;\r\n              break outer;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // On some browsers, horizontal scrolling will cause redraws to\r\n      // happen before the gutter has been realigned, causing it to\r\n      // wriggle around in a most unseemly way. When we have an\r\n      // estimated pixels/delta value, we just handle horizontal\r\n      // scrolling entirely here. It'll be slightly off from native, but\r\n      // better than glitching out.\r\n      if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n        if (dy && canScrollY)\r\n          setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\r\n        setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\r\n        // Only prevent default scrolling if vertical scrolling is\r\n        // actually possible. Otherwise, it causes vertical scroll\r\n        // jitter on OSX trackpads when deltaX is small and deltaY\r\n        // is large (issue #3579)\r\n        if (!dy || (dy && canScrollY))\r\n          e_preventDefault(e);\r\n        display.wheelStartX = null; // Abort measurement, if in progress\r\n        return;\r\n      }\r\n\r\n      // 'Project' the visible viewport to cover the area that is being\r\n      // scrolled into view (if we know enough to estimate it).\r\n      if (dy && wheelPixelsPerUnit != null) {\r\n        var pixels = dy * wheelPixelsPerUnit;\r\n        var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n        if (pixels < 0) top = Math.max(0, top + pixels - 50);\r\n        else bot = Math.min(cm.doc.height, bot + pixels + 50);\r\n        updateDisplaySimple(cm, {top: top, bottom: bot});\r\n      }\r\n\r\n      if (wheelSamples < 20) {\r\n        if (display.wheelStartX == null) {\r\n          display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n          display.wheelDX = dx; display.wheelDY = dy;\r\n          setTimeout(function() {\r\n            if (display.wheelStartX == null) return;\r\n            var movedX = scroll.scrollLeft - display.wheelStartX;\r\n            var movedY = scroll.scrollTop - display.wheelStartY;\r\n            var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n              (movedX && display.wheelDX && movedX / display.wheelDX);\r\n            display.wheelStartX = display.wheelStartY = null;\r\n            if (!sample) return;\r\n            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n            ++wheelSamples;\r\n          }, 200);\r\n        } else {\r\n          display.wheelDX += dx; display.wheelDY += dy;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // Since the delta values reported on mouse wheel events are\r\n  // unstandardized between browsers and even browser versions, and\r\n  // generally horribly unpredictable, this code starts by measuring\r\n  // the scroll effect that the first few mouse wheel events have,\r\n  // and, from that, detects the way it can convert deltas to pixel\r\n  // offsets afterwards.\r\n  //\r\n  // The reason we want to know the amount a wheel event will scroll\r\n  // is that it gives us a chance to update the display before the\r\n  // actual scrolling happens, reducing flickering.\r\n\r\n  var wheelSamples = 0, \r\n    wheelPixelsPerUnit = null;\r\n  // Fill in a browser-detected starting value on browsers where we\r\n  // know one. These don't have to be accurate -- the result of them\r\n  // being wrong would just be a slight flicker on the first wheel\r\n  // scroll (if it is large enough).\r\n  if (browser.ie) {\r\n    wheelPixelsPerUnit = -.53;\r\n  } else if (browser.gecko) {\r\n    wheelPixelsPerUnit = 15;\r\n  } else if (browser.chrome) {\r\n    wheelPixelsPerUnit = -.7;\r\n  } else if (browser.safari) {\r\n    wheelPixelsPerUnit = -1/3;\r\n  }\r\n\r\n  var wheelEventDelta = function(e) {\r\n    var dx = e.wheelDeltaX, \r\n        dy = e.wheelDeltaY;\r\n\r\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\r\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\r\n    else if (dy == null) dy = e.wheelDelta;\r\n    return {x: dx, y: dy};\r\n  };\r\n\r\n  CodeMirror.wheelEventPixels = function(e) {\r\n    var delta = wheelEventDelta(e);\r\n        delta.x *= wheelPixelsPerUnit;\r\n        delta.y *= wheelPixelsPerUnit;\r\n    return delta;\r\n  };\r\n\r\n\r\n\r\n});\r\n"]}