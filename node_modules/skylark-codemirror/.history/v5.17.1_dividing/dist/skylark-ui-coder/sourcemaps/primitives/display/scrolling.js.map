{"version":3,"sources":["primitives/display/scrolling.js"],"names":["define","CoderCtor","partial","maybeScrollWindow","coords","cm","this","signalDOMEvent","display","box","sizer","getBoundingClientRect","doScroll","top","bottom","window","innerHeight","document","documentElement","clientHeight","phantom","scrollNode","elt","viewOffset","paddingTop","scrollGap","barHeight","left","lineSpace","appendChild","scrollIntoView","removeChild","scrollPosIntoView","pos","end","margin","limit","changed","cursorCoords","endCoords","scrollPos","calculateScrollPos","Math","min","max","startTop","doc","scrollTop","startLeft","scrollLeft","setScrollTop","abs","setScrollLeft","x1","y1","x2","y2","snapMargin","textHeight","screentop","curOp","scroller","screen","displayHeight","result","docBottom","height","paddingVert","atTop","atBottom","newTop","screenleft","screenw","displayWidth","options","fixedGutter","gutters","offsetWidth","tooWide","addToScrollPos","resolveScrollToPos","ensureCursorVisible","cur","getCursor","from","to","lineWrapping","ch","Pos","line","scrollToPos","cursorScrollMargin","isCursor","range","estimateCoords","sPos","right","scrollTo"],"mappings":";;;;;;;AAAAA,QACE,gBACA,SAASC,GAGTA,EAAUC,SAGRC,kBAAoB,SAAUC,GAC5B,GAAIC,GAAKC,IAET,KAAID,EAAGE,eAAe,wBAAtB,CAEA,GAAIC,GAAUH,EAAGG,QACbC,EAAMD,EAAQE,MAAMC,wBACpBC,EAAW,IAIf,IAFIR,EAAOS,IAAMJ,EAAII,IAAM,EAAGD,GAAW,EAChCR,EAAOU,OAASL,EAAII,KAAOE,OAAOC,aAAeC,SAASC,gBAAgBC,gBAAeP,GAAW,GAC7F,MAAZA,IAAqBQ,QAAS,CAChC,GAAIC,GAAaC,IAAI,MAAO,IAAU,KAAM,6BACtBlB,EAAOS,IAAML,EAAQe,WAAaC,WAAWnB,EAAGG,UAAY,gBAC5DJ,EAAOU,OAASV,EAAOS,IAAMY,UAAUpB,GAAMG,EAAQkB,WAAa,aACnEtB,EAAOuB,KAAO,kBACnCtB,GAAGG,QAAQoB,UAAUC,YAAYR,GACjCA,EAAWS,eAAelB,GAC1BP,EAAGG,QAAQoB,UAAUG,YAAYV,MAOrCW,kBAAoB,SAAUC,EAAKC,EAAKC,GACtC,GAAI9B,GAAKC,IAEK,OAAV6B,IAAgBA,EAAS,EAC7B,KAAK,GAAIC,GAAQ,EAAGA,EAAQ,EAAGA,IAAS,CACtC,GAAIC,IAAU,EAAOjC,EAASkC,aAAajC,EAAI4B,GAC3CM,EAAaL,GAAOA,GAAOD,EAAeK,aAAajC,EAAI6B,GAA1B9B,EACjCoC,EAAYnC,EAAGoC,mBAAoBC,KAAKC,IAAIvC,EAAOuB,KAAMY,EAAUZ,MACpCe,KAAKC,IAAIvC,EAAOS,IAAK0B,EAAU1B,KAAOsB,EACtCO,KAAKE,IAAIxC,EAAOuB,KAAMY,EAAUZ,MAChCe,KAAKE,IAAIxC,EAAOU,OAAQyB,EAAUzB,QAAUqB,GAC3EU,EAAWxC,EAAGyC,IAAIC,UAAWC,EAAY3C,EAAGyC,IAAIG,UASpD,IAR2B,MAAvBT,EAAUO,YACZG,aAAa7C,EAAImC,EAAUO,WACvBL,KAAKS,IAAI9C,EAAGyC,IAAIC,UAAYF,GAAY,IAAGR,GAAU,IAE/B,MAAxBG,EAAUS,aACZG,cAAc/C,EAAImC,EAAUS,YACxBP,KAAKS,IAAI9C,EAAGyC,IAAIG,WAAaD,GAAa,IAAGX,GAAU,KAExDA,EAAS,MAEhB,MAAOjC,IAIT0B,eAAiB,SAAUuB,EAAIC,EAAIC,EAAIC,GACrC,GAAInD,GAAKC,KAELkC,EAAYnC,EAAGoC,mBAAoBY,EAAIC,EAAIC,EAAIC,EACxB,OAAvBhB,EAAUO,WAAmBG,aAAa7C,EAAImC,EAAUO,WAChC,MAAxBP,EAAUS,YAAoBG,cAAc/C,EAAImC,EAAUS,aAOhER,mBAAqB,SAAUY,EAAIC,EAAIC,EAAIC,GACzC,GAAInD,GAAKC,KAELE,EAAUH,EAAGG,QAASiD,EAAaC,WAAWrD,EAAGG,QACjD8C,GAAK,IAAGA,EAAK,EAEjB,IAAIK,GAAYtD,EAAGuD,OAA+B,MAAtBvD,EAAGuD,MAAMb,UAAoB1C,EAAGuD,MAAMb,UAAYvC,EAAQqD,SAASd,UAC3Fe,EAASC,cAAc1D,GAAK2D,IAE5BR,GAAKF,EAAKQ,IAAQN,EAAKF,EAAKQ,EAChC,IAAIG,GAAY5D,EAAGyC,IAAIoB,OAASC,YAAY3D,GACxC4D,EAAQd,EAAKG,EAAYY,EAAWb,EAAKS,EAAYR,CACzD,IAAIH,EAAKK,EACPK,EAAOjB,UAAYqB,EAAQ,EAAId,MAC1B,IAAIE,EAAKG,EAAYG,EAAQ,CAClC,GAAIQ,GAAS5B,KAAKC,IAAIW,GAAKe,EAAWJ,EAAYT,GAAMM,EACpDQ,IAAUX,IAAWK,EAAOjB,UAAYuB,GAG9C,GAAIC,GAAalE,EAAGuD,OAAgC,MAAvBvD,EAAGuD,MAAMX,WAAqB5C,EAAGuD,MAAMX,WAAazC,EAAQqD,SAASZ,WAC9FuB,EAAUnE,EAAGoE,gBAAkBpE,EAAGqE,QAAQC,YAAcnE,EAAQoE,QAAQC,YAAc,GACtFC,EAAUvB,EAAKF,EAAKmB,CAQxB,OAPIM,KAASvB,EAAKF,EAAKmB,GACnBnB,EAAK,GACPW,EAAOf,WAAa,EACbI,EAAKkB,EACZP,EAAOf,WAAaP,KAAKE,IAAI,EAAGS,GAAMyB,EAAU,EAAI,KAC7CvB,EAAKiB,EAAUD,EAAa,IACnCP,EAAOf,WAAaM,GAAMuB,EAAU,EAAI,IAAMN,GACzCR,GAKTe,eAAiB,SAAUpD,EAAMd,GAC/B,GAAIR,GAAKC,IAEG,OAARqB,GAAuB,MAAPd,GAClBR,EAAG2E,qBAEO,MAARrD,IACFtB,EAAGuD,MAAMX,YAAqC,MAAvB5C,EAAGuD,MAAMX,WAAqB5C,EAAGyC,IAAIG,WAAa5C,EAAGuD,MAAMX,YAActB,GACvF,MAAPd,IACFR,EAAGuD,MAAMb,WAAmC,MAAtB1C,EAAGuD,MAAMb,UAAoB1C,EAAGyC,IAAIC,UAAY1C,EAAGuD,MAAMb,WAAalC,IAKhGoE,oBAAsB,WACpB,GAAI5E,GAAKC,IAETD,GAAG2E,oBACH,IAAIE,GAAM7E,EAAG8E,YAAaC,EAAOF,EAAKG,EAAKH,CACtC7E,GAAGqE,QAAQY,eACdF,EAAOF,EAAIK,GAAKC,IAAIN,EAAIO,KAAMP,EAAIK,GAAK,GAAKL,EAC5CG,EAAKG,IAAIN,EAAIO,KAAMP,EAAIK,GAAK,IAE9BlF,EAAGuD,MAAM8B,aAAeN,KAAMA,EAAMC,GAAIA,EAAIlD,OAAQ9B,EAAGqE,QAAQiB,mBAAoBC,UAAU,IAO/FZ,mBAAqB,WACnB,GAAI3E,GAAKC,KAELuF,EAAQxF,EAAGuD,MAAM8B,WACrB,IAAIG,EAAO,CACTxF,EAAGuD,MAAM8B,YAAc,IACvB,IAAIN,GAAO/E,EAAGyF,eAAeD,EAAMT,MAAOC,EAAKhF,EAAGyF,eAAeD,EAAMR,IACnEU,EAAO1F,EAAGoC,mBAAmBC,KAAKC,IAAIyC,EAAKzD,KAAM0D,EAAG1D,MAC1Be,KAAKC,IAAIyC,EAAKvE,IAAKwE,EAAGxE,KAAOgF,EAAM1D,OACnCO,KAAKE,IAAIwC,EAAKY,MAAOX,EAAGW,OACxBtD,KAAKE,IAAIwC,EAAKtE,OAAQuE,EAAGvE,QAAU+E,EAAM1D,OACvE9B,GAAG4F,SAASF,EAAK9C,WAAY8C,EAAKhD","file":"../../../primitives/display/scrolling.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  // SCROLLING THINGS INTO VIEW\r\n\r\n  CoderCtor.partial({\r\n    // If an editor sits on the top or bottom of the window, partially\r\n    // scrolled out of view, this ensures that the cursor is visible.\r\n    maybeScrollWindow : function (coords) {\r\n      var cm = this;\r\n\r\n      if (cm.signalDOMEvent(\"scrollCursorIntoView\")) return;\r\n\r\n      var display = cm.display, \r\n          box = display.sizer.getBoundingClientRect(), \r\n          doScroll = null;\r\n          \r\n      if (coords.top + box.top < 0) doScroll = true;\r\n      else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\r\n      if (doScroll != null && !phantom) {\r\n        var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\r\n                             (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\r\n                             (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\r\n                             coords.left + \"px; width: 2px;\");\r\n        cm.display.lineSpace.appendChild(scrollNode);\r\n        scrollNode.scrollIntoView(doScroll);\r\n        cm.display.lineSpace.removeChild(scrollNode);\r\n      }\r\n    },\r\n\r\n    // Scroll a given position into view (immediately), verifying that\r\n    // it actually became visible (as line heights are accurately\r\n    // measured, the position of something may 'drift' during drawing).\r\n    scrollPosIntoView : function (pos, end, margin) {\r\n      var cm = this;\r\n\r\n      if (margin == null) margin = 0;\r\n      for (var limit = 0; limit < 5; limit++) {\r\n        var changed = false, coords = cursorCoords(cm, pos);\r\n        var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n        var scrollPos = cm.calculateScrollPos( Math.min(coords.left, endCoords.left),\r\n                                           Math.min(coords.top, endCoords.top) - margin,\r\n                                           Math.max(coords.left, endCoords.left),\r\n                                           Math.max(coords.bottom, endCoords.bottom) + margin);\r\n        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n        if (scrollPos.scrollTop != null) {\r\n          setScrollTop(cm, scrollPos.scrollTop);\r\n          if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\r\n        }\r\n        if (scrollPos.scrollLeft != null) {\r\n          setScrollLeft(cm, scrollPos.scrollLeft);\r\n          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\r\n        }\r\n        if (!changed) break;\r\n      }\r\n      return coords;\r\n    },\r\n\r\n    // Scroll a given set of coordinates into view (immediately).\r\n    scrollIntoView : function (x1, y1, x2, y2) {\r\n      var cm = this;\r\n\r\n      var scrollPos = cm.calculateScrollPos( x1, y1, x2, y2);\r\n      if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\r\n      if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\r\n    },\r\n\r\n    // Calculate a new scroll position needed to scroll the given\r\n    // rectangle into view. Returns an object with scrollTop and\r\n    // scrollLeft properties. When these are undefined, the\r\n    // vertical/horizontal position does not need to be adjusted.\r\n    calculateScrollPos : function (x1, y1, x2, y2) {\r\n      var cm = this;\r\n\r\n      var display = cm.display, snapMargin = textHeight(cm.display);\r\n      if (y1 < 0) y1 = 0;\r\n\r\n      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n      var screen = displayHeight(cm), result = {};\r\n      \r\n      if (y2 - y1 > screen) y2 = y1 + screen;\r\n      var docBottom = cm.doc.height + paddingVert(display);\r\n      var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\r\n      if (y1 < screentop) {\r\n        result.scrollTop = atTop ? 0 : y1;\r\n      } else if (y2 > screentop + screen) {\r\n        var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\r\n        if (newTop != screentop) result.scrollTop = newTop;\r\n      }\r\n\r\n      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n      var screenw = cm.displayWidth() - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\r\n      var tooWide = x2 - x1 > screenw;\r\n      if (tooWide) x2 = x1 + screenw;\r\n      if (x1 < 10)\r\n        result.scrollLeft = 0;\r\n      else if (x1 < screenleft)\r\n        result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\r\n      else if (x2 > screenw + screenleft - 3)\r\n        result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\r\n      return result;\r\n    },\r\n\r\n    // Store a relative adjustment to the scroll position in the current\r\n    // operation (to be applied when the operation finishes).\r\n    addToScrollPos : function (left, top) {\r\n      var cm = this;\r\n\r\n      if (left != null || top != null) {\r\n        cm.resolveScrollToPos();\r\n      }\r\n      if (left != null)\r\n        cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\r\n      if (top != null)\r\n        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n    },\r\n\r\n    // Make sure that at the end of the operation the current cursor is\r\n    // shown.\r\n    ensureCursorVisible : function () {\r\n      var cm = this;\r\n\r\n      cm.resolveScrollToPos();\r\n      var cur = cm.getCursor(), from = cur, to = cur;\r\n      if (!cm.options.lineWrapping) {\r\n        from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\r\n        to = Pos(cur.line, cur.ch + 1);\r\n      }\r\n      cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\r\n    },\r\n\r\n    // When an operation has its scrollToPos property set, and another\r\n    // scroll action is applied before the end of the operation, this\r\n    // 'simulates' scrolling that position into view in a cheap way, so\r\n    // that the effect of intermediate scroll commands is not ignored.\r\n    resolveScrollToPos : function () {\r\n      var cm = this;\r\n\r\n      var range = cm.curOp.scrollToPos;\r\n      if (range) {\r\n        cm.curOp.scrollToPos = null;\r\n        var from = cm.estimateCoords(range.from), to = cm.estimateCoords(range.to);\r\n        var sPos = cm.calculateScrollPos(Math.min(from.left, to.left),\r\n                                      Math.min(from.top, to.top) - range.margin,\r\n                                      Math.max(from.right, to.right),\r\n                                      Math.max(from.bottom, to.bottom) + range.margin);\r\n        cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\r\n      }\r\n    }\r\n  });\r\n\r\n});\r\n"]}