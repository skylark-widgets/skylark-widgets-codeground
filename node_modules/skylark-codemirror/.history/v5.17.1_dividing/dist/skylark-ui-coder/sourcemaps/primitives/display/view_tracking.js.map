{"version":3,"sources":["primitives/display/view_tracking.js"],"names":["define","CoderCtor","partial","regChange","from","to","lendiff","cm","this","doc","first","size","display","viewTo","updateLineNumbers","curOp","viewChanged","sawCollapsedSpans","visualLineNo","resetView","viewFrom","visualLineEndNo","cut","viewCuttingPoint","view","slice","index","lineN","cutTop","cutBot","concat","buildViewArray","ext","externalMeasured","regLineChange","line","type","lineView","findViewIndex","node","arr","changes","indexOf","push","viewOffset","n","i","length","oldN","newN","dir","diff","adjustView","countDirtyView","dirty","hidden"],"mappings":"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","file":"../../../primitives/display/view_tracking.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  CoderCtor.partial({\r\n    // Updates the display.view data structure for a given change to the\r\n    // document. From and to are in pre-change coordinates. Lendiff is\r\n    // the amount of lines added or subtracted by the change. This is\r\n    // used for changes that span multiple lines, or change the way\r\n    // lines are divided into visual lines. regLineChange (below)\r\n    // registers single-line changes.\r\n    regChange : function (from, to, lendiff) {\r\n      var cm = this;\r\n      if (from == null) from = cm.doc.first;\r\n      if (to == null) to = cm.doc.first + cm.doc.size;\r\n      if (!lendiff) lendiff = 0;\r\n\r\n      var display = cm.display;\r\n      if (lendiff && to < display.viewTo &&\r\n          (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n        display.updateLineNumbers = from;\r\n\r\n      cm.curOp.viewChanged = true;\r\n\r\n      if (from >= display.viewTo) { // Change after\r\n        if (sawCollapsedSpans && cm.visualLineNo(cm.doc, from) < display.viewTo)\r\n          resetView(cm);\r\n      } else if (to <= display.viewFrom) { // Change before\r\n        if (sawCollapsedSpans && cm.visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n          resetView(cm);\r\n        } else {\r\n          display.viewFrom += lendiff;\r\n          display.viewTo += lendiff;\r\n        }\r\n      } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n        cm.resetView();\r\n      } else if (from <= display.viewFrom) { // Top overlap\r\n        var cut = cm.viewCuttingPoint(to, to + lendiff, 1);\r\n        if (cut) {\r\n          display.view = display.view.slice(cut.index);\r\n          display.viewFrom = cut.lineN;\r\n          display.viewTo += lendiff;\r\n        } else {\r\n          resetView(cm);\r\n        }\r\n      } else if (to >= display.viewTo) { // Bottom overlap\r\n        var cut = cm.viewCuttingPoint(from, from, -1);\r\n        if (cut) {\r\n          display.view = display.view.slice(0, cut.index);\r\n          display.viewTo = cut.lineN;\r\n        } else {\r\n          cm.resetView();\r\n        }\r\n      } else { // Gap in the middle\r\n        var cutTop = cm.viewCuttingPoint(from, from, -1);\r\n        var cutBot = cm.viewCuttingPoint(to, to + lendiff, 1);\r\n        if (cutTop && cutBot) {\r\n          display.view = display.view.slice(0, cutTop.index)\r\n            .concat(cm.buildViewArray(cutTop.lineN, cutBot.lineN))\r\n            .concat(display.view.slice(cutBot.index));\r\n          display.viewTo += lendiff;\r\n        } else {\r\n          cm.resetView();\r\n        }\r\n      }\r\n\r\n      var ext = display.externalMeasured;\r\n      if (ext) {\r\n        if (to < ext.lineN)\r\n          ext.lineN += lendiff;\r\n        else if (from < ext.lineN + ext.size)\r\n          display.externalMeasured = null;\r\n      }\r\n    },\r\n\r\n    // Register a change to a single line. Type must be one of \"text\",\r\n    // \"gutter\", \"class\", \"widget\"\r\n    regLineChange : function (line, type) {\r\n      var cm = this;\r\n      cm.curOp.viewChanged = true;\r\n      var display = cm.display, ext = cm.display.externalMeasured;\r\n      if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n        display.externalMeasured = null;\r\n\r\n      if (line < display.viewFrom || line >= display.viewTo) return;\r\n      var lineView = display.view[findViewIndex(cm, line)];\r\n      if (lineView.node == null) return;\r\n      var arr = lineView.changes || (lineView.changes = []);\r\n      if (indexOf(arr, type) == -1) arr.push(type);\r\n    },\r\n\r\n    // Clear the view.\r\n    resetView : function () {\r\n      var cm = this;\r\n\r\n      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n      cm.display.view = [];\r\n      cm.display.viewOffset = 0;\r\n    },\r\n\r\n    // Find the view element corresponding to a given line. Return null\r\n    // when the line isn't visible.\r\n    findViewIndex : function (n) {\r\n      var cm = this;\r\n\r\n      if (n >= cm.display.viewTo) return null;\r\n      n -= cm.display.viewFrom;\r\n      if (n < 0) return null;\r\n      var view = cm.display.view;\r\n      for (var i = 0; i < view.length; i++) {\r\n        n -= view[i].size;\r\n        if (n < 0) return i;\r\n      }\r\n    },\r\n\r\n    viewCuttingPoint : function (oldN, newN, dir) {\r\n      var cm = this;\r\n\r\n      var index = cm.findViewIndex(oldN), diff, view = cm.display.view;\r\n      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n        return {index: index, lineN: newN};\r\n      for (var i = 0, n = cm.display.viewFrom; i < index; i++)\r\n        n += view[i].size;\r\n      if (n != oldN) {\r\n        if (dir > 0) {\r\n          if (index == view.length - 1) return null;\r\n          diff = (n + view[index].size) - oldN;\r\n          index++;\r\n        } else {\r\n          diff = n - oldN;\r\n        }\r\n        oldN += diff; newN += diff;\r\n      }\r\n      while (cm.visualLineNo(cm.doc, newN) != newN) {\r\n        if (index == (dir < 0 ? 0 : view.length - 1)) return null;\r\n        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n        index += dir;\r\n      }\r\n      return {index: index, lineN: newN};\r\n    },\r\n\r\n    // Force the view to cover a given range, adding empty view element\r\n    // or clipping off existing ones as needed.\r\n    adjustView : function (from, to) {\r\n      var cm = this;\r\n\r\n      var display = cm.display, view = display.view;\r\n      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n        display.view = cm.buildViewArray(from, to);\r\n        display.viewFrom = from;\r\n      } else {\r\n        if (display.viewFrom > from)\r\n          display.view = cm.buildViewArray(from, display.viewFrom).concat(display.view);\r\n        else if (display.viewFrom < from)\r\n          display.view = display.view.slice(cm.findViewIndex(from));\r\n        display.viewFrom = from;\r\n        if (display.viewTo < to)\r\n          display.view = display.view.concat(cm.buildViewArray(display.viewTo, to));\r\n        else if (display.viewTo > to)\r\n          display.view = display.view.slice(0, cm.findViewIndex(to));\r\n      }\r\n      display.viewTo = to;\r\n    },\r\n\r\n    // Count the number of lines in the view whose DOM representation is\r\n    // out of date (or nonexistent).\r\n    countDirtyView : function () {\r\n      var cm = this;\r\n\r\n      var view = cm.display.view, dirty = 0;\r\n      for (var i = 0; i < view.length; i++) {\r\n        var lineView = view[i];\r\n        if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\r\n      }\r\n      return dirty;\r\n    }\r\n  });\r\n\r\n});\r\n"]}