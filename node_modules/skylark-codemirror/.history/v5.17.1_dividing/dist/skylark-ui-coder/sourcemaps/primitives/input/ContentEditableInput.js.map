{"version":3,"sources":["primitives/input/ContentEditableInput.js"],"names":["define","Evented","CoderCtor","inherit","klassName","_construct","cm","this","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","Delayed","gracePeriod","init","display","onCopyCut","e","signalDOMEvent","somethingSelected","lastCopied","lineWise","text","getSelections","type","replaceSelection","options","lineWiseCopyCut","ranges","copyableRanges","operation","setSelections","sel_dontScroll","clipboardData","ios","preventDefault","clearData","setData","join","kludge","hiddenTextarea","te","firstChild","lineSpace","insertBefore","value","hadFocus","document","activeElement","selectInput","setTimeout","removeChild","focus","input","div","lineDiv","disableBrowserMagic","on","handlePaste","data","composing","sel","doc","startData","prim","primary","line","getLine","head","found","indexOf","Math","max","ch","length","simpleSelection","Pos","ours","test","handled","applyComposition","forceCompositionEnd","isReadOnly","pollContent","runInOp","regChange","prepareSelection","result","state","focused","showSelection","info","takeFocus","view","showPrimarySelection","showMultipleSelections","window","getSelection","curAnchor","domToPos","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","bad","cmp","minPos","from","maxPos","to","start","posToDOM","end","old","rangeCount","getRangeAt","measure","map","maps","node","offset","rng","range","gecko","collapse","collapsed","addRange","removeAllRanges","startGracePeriod","rememberSelection","clearTimeout","selectionChanged","curOp","removeChildrenAndAdd","cursorDiv","cursors","selectionDiv","selection","selectionInEditor","commonAncestorContainer","contains","readOnly","blur","getField","supportsTouch","receivedFocus","poll","pollSelection","set","pollInterval","anchor","setSelection","viewFrom","viewTo","fromIndex","findViewIndex","fromLine","lineNo","fromNode","nextSibling","toIndex","toLine","toNode","lastChild","previousSibling","newText","splitLines","domTextBetween","oldText","getBetween","lst","pop","shift","cutFront","cutEnd","newTop","oldTop","maxCutFront","min","charCodeAt","newBot","oldBot","maxCutEnd","slice","chFrom","chTo","replaceRange","ensurePolled","reset","applyTextInput","setUneditable","contentEditable","onKeyPress","String","fromCharCode","charCode","keyCode","readOnlyChanged","val","onContextMenu","nothing","resetPosition","needsContentAttribute"],"mappings":"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","file":"../../../primitives/input/ContentEditableInput.js","sourcesContent":["define([\r\n  \"skylark-langx/Evented\",\r\n  \"../CoderCtor\"\r\n],function(Evented,CoderCtor) {\r\n  // CONTENTEDITABLE INPUT STYLE\r\n\r\n  var ContentEditableInput = Evented.inherit({\r\n    klassName : \"ContentEditableInput\",\r\n    \r\n    _construct : function(cm) {\r\n      this.cm = cm;\r\n      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\r\n      this.polling = new Delayed();\r\n      this.gracePeriod = false;\r\n    },\r\n\r\n    init: function(display) {\r\n      var input = this, cm = input.cm;\r\n      var div = input.div = display.lineDiv;\r\n      disableBrowserMagic(div);\r\n\r\n      on(div, \"paste\", function(e) {\r\n        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\r\n      })\r\n\r\n      on(div, \"compositionstart\", function(e) {\r\n        var data = e.data;\r\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\r\n        if (!data) return;\r\n        var prim = cm.doc.sel.primary();\r\n        var line = cm.getLine(prim.head.line);\r\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\r\n        if (found > -1 && found <= prim.head.ch)\r\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\r\n                                                Pos(prim.head.line, found + data.length));\r\n      });\r\n      on(div, \"compositionupdate\", function(e) {\r\n        input.composing.data = e.data;\r\n      });\r\n      on(div, \"compositionend\", function(e) {\r\n        var ours = input.composing;\r\n        if (!ours) return;\r\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\r\n          ours.data = e.data;\r\n        // Need a small delay to prevent other code (input event,\r\n        // selection polling) from doing damage when fired right after\r\n        // compositionend.\r\n        setTimeout(function() {\r\n          if (!ours.handled)\r\n            input.applyComposition(ours);\r\n          if (input.composing == ours)\r\n            input.composing = null;\r\n        }, 50);\r\n      });\r\n\r\n      on(div, \"touchstart\", function() {\r\n        input.forceCompositionEnd();\r\n      });\r\n\r\n      on(div, \"input\", function() {\r\n        if (input.composing) return;\r\n        if (cm.isReadOnly() || !input.pollContent())\r\n          runInOp(input.cm, function() {regChange(cm);});\r\n      });\r\n\r\n      function onCopyCut(e) {\r\n        if (signalDOMEvent(cm, e)) return\r\n        if (cm.somethingSelected()) {\r\n          lastCopied = {lineWise: false, text: cm.getSelections()};\r\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\r\n        } else if (!cm.options.lineWiseCopyCut) {\r\n          return;\r\n        } else {\r\n          var ranges = copyableRanges(cm);\r\n          lastCopied = {lineWise: true, text: ranges.text};\r\n          if (e.type == \"cut\") {\r\n            cm.operation(function() {\r\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\r\n              cm.replaceSelection(\"\", null, \"cut\");\r\n            });\r\n          }\r\n        }\r\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\r\n        if (e.clipboardData && !ios) {\r\n          e.preventDefault();\r\n          e.clipboardData.clearData();\r\n          e.clipboardData.setData(\"text/plain\", lastCopied.text.join(\"\\n\"));\r\n        } else {\r\n          // Old-fashioned briefly-focus-a-textarea hack\r\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\r\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\r\n          te.value = lastCopied.text.join(\"\\n\");\r\n          var hadFocus = document.activeElement;\r\n          selectInput(te);\r\n          setTimeout(function() {\r\n            cm.display.lineSpace.removeChild(kludge);\r\n            hadFocus.focus();\r\n          }, 50);\r\n        }\r\n      }\r\n      on(div, \"copy\", onCopyCut);\r\n      on(div, \"cut\", onCopyCut);\r\n    },\r\n\r\n    prepareSelection: function() {\r\n      var result = prepareSelection(this.cm, false);\r\n      result.focus = this.cm.state.focused;\r\n      return result;\r\n    },\r\n\r\n    showSelection: function(info, takeFocus) {\r\n      if (!info || !this.cm.display.view.length) return;\r\n      if (info.focus || takeFocus) this.showPrimarySelection();\r\n      this.showMultipleSelections(info);\r\n    },\r\n\r\n    showPrimarySelection: function() {\r\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\r\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\r\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\r\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\r\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\r\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\r\n        return;\r\n\r\n      var start = posToDOM(this.cm, prim.from());\r\n      var end = posToDOM(this.cm, prim.to());\r\n      if (!start && !end) return;\r\n\r\n      var view = this.cm.display.view;\r\n      var old = sel.rangeCount && sel.getRangeAt(0);\r\n      if (!start) {\r\n        start = {node: view[0].measure.map[2], offset: 0};\r\n      } else if (!end) { // FIXME dangerously hacky\r\n        var measure = view[view.length - 1].measure;\r\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\r\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\r\n      }\r\n\r\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\r\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\r\n      if (rng) {\r\n        if (!gecko && this.cm.state.focused) {\r\n          sel.collapse(start.node, start.offset);\r\n          if (!rng.collapsed) sel.addRange(rng);\r\n        } else {\r\n          sel.removeAllRanges();\r\n          sel.addRange(rng);\r\n        }\r\n        if (old && sel.anchorNode == null) sel.addRange(old);\r\n        else if (gecko) this.startGracePeriod();\r\n      }\r\n      this.rememberSelection();\r\n    },\r\n\r\n    startGracePeriod: function() {\r\n      var input = this;\r\n      clearTimeout(this.gracePeriod);\r\n      this.gracePeriod = setTimeout(function() {\r\n        input.gracePeriod = false;\r\n        if (input.selectionChanged())\r\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\r\n      }, 20);\r\n    },\r\n\r\n    showMultipleSelections: function(info) {\r\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\r\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\r\n    },\r\n\r\n    rememberSelection: function() {\r\n      var sel = window.getSelection();\r\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\r\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\r\n    },\r\n\r\n    selectionInEditor: function() {\r\n      var sel = window.getSelection();\r\n      if (!sel.rangeCount) return false;\r\n      var node = sel.getRangeAt(0).commonAncestorContainer;\r\n      return contains(this.div, node);\r\n    },\r\n\r\n    focus: function() {\r\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\r\n    },\r\n    blur: function() { this.div.blur(); },\r\n    getField: function() { return this.div; },\r\n\r\n    supportsTouch: function() { return true; },\r\n\r\n    receivedFocus: function() {\r\n      var input = this;\r\n      if (this.selectionInEditor())\r\n        this.pollSelection();\r\n      else\r\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\r\n\r\n      function poll() {\r\n        if (input.cm.state.focused) {\r\n          input.pollSelection();\r\n          input.polling.set(input.cm.options.pollInterval, poll);\r\n        }\r\n      }\r\n      this.polling.set(this.cm.options.pollInterval, poll);\r\n    },\r\n\r\n    selectionChanged: function() {\r\n      var sel = window.getSelection();\r\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\r\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\r\n    },\r\n\r\n    pollSelection: function() {\r\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\r\n        var sel = window.getSelection(), cm = this.cm;\r\n        this.rememberSelection();\r\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\r\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\r\n        if (anchor && head) runInOp(cm, function() {\r\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\r\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\r\n        });\r\n      }\r\n    },\r\n\r\n    pollContent: function() {\r\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\r\n      var from = sel.from(), to = sel.to();\r\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\r\n\r\n      var fromIndex;\r\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\r\n        var fromLine = lineNo(display.view[0].line);\r\n        var fromNode = display.view[0].node;\r\n      } else {\r\n        var fromLine = lineNo(display.view[fromIndex].line);\r\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\r\n      }\r\n      var toIndex = findViewIndex(cm, to.line);\r\n      if (toIndex == display.view.length - 1) {\r\n        var toLine = display.viewTo - 1;\r\n        var toNode = display.lineDiv.lastChild;\r\n      } else {\r\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\r\n        var toNode = display.view[toIndex + 1].node.previousSibling;\r\n      }\r\n\r\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\r\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\r\n      while (newText.length > 1 && oldText.length > 1) {\r\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\r\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\r\n        else break;\r\n      }\r\n\r\n      var cutFront = 0, cutEnd = 0;\r\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\r\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\r\n        ++cutFront;\r\n      var newBot = lst(newText), oldBot = lst(oldText);\r\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\r\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\r\n      while (cutEnd < maxCutEnd &&\r\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\r\n        ++cutEnd;\r\n\r\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\r\n      newText[0] = newText[0].slice(cutFront);\r\n\r\n      var chFrom = Pos(fromLine, cutFront);\r\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\r\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\r\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\r\n        return true;\r\n      }\r\n    },\r\n\r\n    ensurePolled: function() {\r\n      this.forceCompositionEnd();\r\n    },\r\n    reset: function() {\r\n      this.forceCompositionEnd();\r\n    },\r\n    forceCompositionEnd: function() {\r\n      if (!this.composing || this.composing.handled) return;\r\n      this.applyComposition(this.composing);\r\n      this.composing.handled = true;\r\n      this.div.blur();\r\n      this.div.focus();\r\n    },\r\n    applyComposition: function(composing) {\r\n      if (this.cm.isReadOnly())\r\n        operation(this.cm, regChange)(this.cm)\r\n      else if (composing.data && composing.data != composing.startData)\r\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\r\n    },\r\n\r\n    setUneditable: function(node) {\r\n      node.contentEditable = \"false\"\r\n    },\r\n\r\n    onKeyPress: function(e) {\r\n      e.preventDefault();\r\n      if (!this.cm.isReadOnly())\r\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\r\n    },\r\n\r\n    readOnlyChanged: function(val) {\r\n      this.div.contentEditable = String(val != \"nocursor\")\r\n    },\r\n\r\n    onContextMenu: nothing,\r\n    resetPosition: nothing,\r\n\r\n    needsContentAttribute: true\r\n  });\r\n\r\n\r\n  function badPos(pos, bad) { \r\n    if (bad) pos.bad = true; \r\n    return pos; \r\n  }\r\n\r\n\r\n});\r\n"]}