{"version":3,"sources":["primitives/input/indent.js"],"names":["define","CoderCtor","partial","indentLine","n","how","aggressive","state","cm","this","doc","mode","indent","getStateBefore","tabSize","options","line","getLine","curSpace","countColumn","text","stateAfter","indentation","curSpaceString","match","test","slice","length","Pass","first","indentUnit","Math","max","indentString","pos","indentWithTabs","i","floor","spaceStr","replaceRange","Pos","sel","ranges","range","head","ch","replaceOneSelection","Range"],"mappings":";;;;;;;AAAAA,QACE,gBACA,SAASC,GAETA,EAAUC,SAMRC,WAAa,SAAUC,EAAGC,EAAKC,GAC7B,GAEkBC,GAFdC,EAAKC,KAELC,EAAMF,EAAGE,GACF,OAAPL,IAAaA,EAAM,OACZ,SAAPA,IAGGK,EAAIC,KAAKC,OACTL,EAAQM,eAAeL,EAAIJ,GADVC,EAAM,OAI9B,IAAIS,GAAUN,EAAGO,QAAQD,QACrBE,EAAOC,QAAQP,EAAKN,GACpBc,EAAWC,YAAYH,EAAKI,KAAM,KAAMN,EAExCE,GAAKK,aAAYL,EAAKK,WAAa,KACvC,IAAiDC,GAA7CC,EAAiBP,EAAKI,KAAKI,MAAM,QAAQ,EAC7C,IAAKlB,GAAe,KAAKmB,KAAKT,EAAKI,OAG5B,GAAW,SAAPf,IACTiB,EAAcZ,EAAIC,KAAKC,OAAOL,EAAOS,EAAKI,KAAKM,MAAMH,EAAeI,QAASX,EAAKI,MAC9EE,GAAeM,MAAQN,EAAc,KAAK,CAC5C,IAAKhB,EAAY,MACjBD,GAAM,YANRiB,GAAc,EACdjB,EAAM,KAQG,SAAPA,EACiBiB,EAAflB,EAAIM,EAAImB,MAAqBV,YAAYF,QAAQP,EAAKN,EAAE,GAAGgB,KAAM,KAAMN,GACxD,EACH,OAAPT,EACTiB,EAAcJ,EAAWV,EAAGO,QAAQe,WACpB,YAAPzB,EACTiB,EAAcJ,EAAWV,EAAGO,QAAQe,WACb,gBAAPzB,KAChBiB,EAAcJ,EAAWb,GAE3BiB,EAAcS,KAAKC,IAAI,EAAGV,EAE1B,IAAIW,GAAe,GAAIC,EAAM,CAC7B,IAAI1B,EAAGO,QAAQoB,eACb,IAAK,GAAIC,GAAIL,KAAKM,MAAMf,EAAcR,GAAUsB,IAAKA,EAAIF,GAAOpB,EAASmB,GAAgB,IAG3F,IAFIC,EAAMZ,IAAaW,GAAgBK,SAAShB,EAAcY,IAE1DD,GAAgBV,EAGlB,MAFAgB,cAAa7B,EAAKuB,EAAcO,IAAIpC,EAAG,GAAIoC,IAAIpC,EAAGmB,EAAeI,QAAS,UAC1EX,EAAKK,WAAa,MACX,CAIP,KAAK,GAAIe,GAAI,EAAGA,EAAI1B,EAAI+B,IAAIC,OAAOf,OAAQS,IAAK,CAC9C,GAAIO,GAAQjC,EAAI+B,IAAIC,OAAON,EAC3B,IAAIO,EAAMC,KAAK5B,MAAQZ,GAAKuC,EAAMC,KAAKC,GAAKtB,EAAeI,OAAQ,CACjE,GAAIO,GAAMM,IAAIpC,EAAGmB,EAAeI,OAChCmB,qBAAoBpC,EAAK0B,EAAG,GAAIW,OAAMb,EAAKA,GAC3C","file":"../../../primitives/input/indent.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n\r\n  CoderCtor.partial({\r\n    // Indent the given line. The how parameter can be \"smart\",\r\n    // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\r\n    // (typically set to true for forced single-line indents), empty\r\n    // lines are not indented, and places where the mode returns Pass\r\n    // are left alone.\r\n    indentLine : function (n, how, aggressive) {\r\n      var cm = this;\r\n\r\n      var doc = cm.doc, state;\r\n      if (how == null) how = \"add\";\r\n      if (how == \"smart\") {\r\n        // Fall back to \"prev\" when the mode doesn't have an indentation\r\n        // method.\r\n        if (!doc.mode.indent) how = \"prev\";\r\n        else state = getStateBefore(cm, n);\r\n      }\r\n\r\n      var tabSize = cm.options.tabSize;\r\n      var line = getLine(doc, n), \r\n          curSpace = countColumn(line.text, null, tabSize);\r\n          \r\n      if (line.stateAfter) line.stateAfter = null;\r\n      var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n      if (!aggressive && !/\\S/.test(line.text)) {\r\n        indentation = 0;\r\n        how = \"not\";\r\n      } else if (how == \"smart\") {\r\n        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n        if (indentation == Pass || indentation > 150) {\r\n          if (!aggressive) return;\r\n          how = \"prev\";\r\n        }\r\n      }\r\n      if (how == \"prev\") {\r\n        if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\r\n        else indentation = 0;\r\n      } else if (how == \"add\") {\r\n        indentation = curSpace + cm.options.indentUnit;\r\n      } else if (how == \"subtract\") {\r\n        indentation = curSpace - cm.options.indentUnit;\r\n      } else if (typeof how == \"number\") {\r\n        indentation = curSpace + how;\r\n      }\r\n      indentation = Math.max(0, indentation);\r\n\r\n      var indentString = \"\", pos = 0;\r\n      if (cm.options.indentWithTabs)\r\n        for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\r\n      if (pos < indentation) indentString += spaceStr(indentation - pos);\r\n\r\n      if (indentString != curSpaceString) {\r\n        replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\r\n        line.stateAfter = null;\r\n        return true;\r\n      } else {\r\n        // Ensure that, if the cursor was in the whitespace at the start\r\n        // of the line, it is moved to the end of that space.\r\n        for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n          var range = doc.sel.ranges[i];\r\n          if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n            var pos = Pos(n, curSpaceString.length);\r\n            replaceOneSelection(doc, i, new Range(pos, pos));\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n});\r\n"]}