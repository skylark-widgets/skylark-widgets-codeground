{"version":3,"sources":["primitives/input/input.js"],"names":["define","CoderCtor","lastCopied","partial","applyTextInput","inserted","deleted","sel","origin","cm","this","doc","display","shift","paste","state","pasteIncoming","textLines","splitLines","multiPaste","ranges","length","text","join","i","push","map","l","range","from","to","empty","Pos","line","ch","overwrite","Math","min","getLine","lst","lineWise","updateInput","curOp","changeEvent","cutIncoming","makeChange","signalLater","triggerElectric","ensureCursorVisible","typing","handlePaste","e","pasted","clipboardData","getData","preventDefault","isReadOnly","options","disableInput","runInOp","electricChars","smartIndent","head","mode","getModeAt","indented","j","indexOf","charAt","indentLine","electricInput","test","slice","copyableRanges","lineRange","anchor","getRange","posToDOM","pos","view","findViewForLine","hidden","info","mapFromLineView","order","getOrder","side","partPos","getBidiPartAt","result","nodeAndOffsetInLineMap","offset","collapse","end","start","domToPos","node","lineNode","lineDiv","childNodes","badPos","clipPos","viewTo","parentNode","lineView","locateNodeInLineView","domTextBetween","fromLine","toLine","recognizeMarker","id","marker","walk","nodeType","cmText","getAttribute","textContent","replace","markerID","found","findMarks","find","getBetween","lineSep","nodeName","closing","val","nodeValue","lineSeparator","nextSibling"],"mappings":"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","file":"../../../primitives/input/input.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  // INPUT HANDLING\r\n\r\n    function disableBrowserMagic(field) {\r\n      field.setAttribute(\"autocorrect\", \"off\");\r\n      field.setAttribute(\"autocapitalize\", \"off\");\r\n      field.setAttribute(\"spellcheck\", \"false\");\r\n    }\r\n\r\n\r\n  // This will be set to a {lineWise: bool, text: [string]} object, so\r\n  // that, when pasting, we know what kind of selections the copied\r\n  // text was made out of.\r\n  var lastCopied = null;\r\n\r\n  CoderCtor.partial({\r\n    applyTextInput : function(inserted, deleted, sel, origin) {\r\n      var cm = this;\r\n\r\n      var doc = cm.doc;\r\n      cm.display.shift = false;\r\n      if (!sel) sel = doc.sel;\r\n\r\n      var paste = cm.state.pasteIncoming || origin == \"paste\";\r\n      var textLines = doc.splitLines(inserted), multiPaste = null\r\n      // When pasing N lines into N selections, insert one line per selection\r\n      if (paste && sel.ranges.length > 1) {\r\n        if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\r\n          if (sel.ranges.length % lastCopied.text.length == 0) {\r\n            multiPaste = [];\r\n            for (var i = 0; i < lastCopied.text.length; i++)\r\n              multiPaste.push(doc.splitLines(lastCopied.text[i]));\r\n          }\r\n        } else if (textLines.length == sel.ranges.length) {\r\n          multiPaste = map(textLines, function(l) { return [l]; });\r\n        }\r\n      }\r\n\r\n      // Normal behavior is to insert the new text into every selection\r\n      for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n        var range = sel.ranges[i];\r\n        var from = range.from(), to = range.to();\r\n        if (range.empty()) {\r\n          if (deleted && deleted > 0) // Handle deletion\r\n            from = Pos(from.line, from.ch - deleted);\r\n          else if (cm.state.overwrite && !paste) // Handle overwrite\r\n            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\r\n          else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\r\n            from = to = Pos(from.line, 0)\r\n        }\r\n        var updateInput = cm.curOp.updateInput;\r\n        var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\r\n                           origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\r\n        makeChange(cm.doc, changeEvent);\r\n        cm.signalLater(\"inputRead\", cm, changeEvent);\r\n      }\r\n      if (inserted && !paste)\r\n        cm.triggerElectric(inserted);\r\n\r\n      cm.ensureCursorVisible();\r\n      cm.curOp.updateInput = updateInput;\r\n      cm.curOp.typing = true;\r\n      cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n    },\r\n\r\n    handlePaste : function (e) {\r\n      var cm = this;\r\n\r\n      var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\r\n      if (pasted) {\r\n        e.preventDefault();\r\n        if (!cm.isReadOnly() && !cm.options.disableInput)\r\n          cm.runInOp(function() { cm.applyTextInput(pasted, 0, null, \"paste\"); });\r\n        return true;\r\n      }\r\n    },\r\n\r\n    triggerElectric : function (inserted) {\r\n      var cm = this;\r\n\r\n      // When an 'electric' character is inserted, immediately trigger a reindent\r\n      if (!cm.options.electricChars || !cm.options.smartIndent) return;\r\n      var sel = cm.doc.sel;\r\n\r\n      for (var i = sel.ranges.length - 1; i >= 0; i--) {\r\n        var range = sel.ranges[i];\r\n        if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\r\n        var mode = cm.getModeAt(range.head);\r\n        var indented = false;\r\n        if (mode.electricChars) {\r\n          for (var j = 0; j < mode.electricChars.length; j++)\r\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n              indented = cm.indentLine(range.head.line, \"smart\");\r\n              break;\r\n            }\r\n        } else if (mode.electricInput) {\r\n          if (mode.electricInput.test(cm.doc.getLine(range.head.line).text.slice(0, range.head.ch)))\r\n            indented = cm.indentLine(range.head.line, \"smart\");\r\n        }\r\n        if (indented) cm.signalLater(\"electricInput\", cm, range.head.line);\r\n      }\r\n    },\r\n\r\n    copyableRanges : function () {\r\n      var cm = this;\r\n\r\n      var text = [], ranges = [];\r\n      for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n        var line = cm.doc.sel.ranges[i].head.line;\r\n        var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n        ranges.push(lineRange);\r\n        text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n      }\r\n      return {text: text, ranges: ranges};\r\n    },\r\n\r\n    posToDOM : function (pos) {\r\n      var cm = this;\r\n\r\n      var view = cm.findViewForLine(pos.line);\r\n      if (!view || view.hidden) return null;\r\n      var line = cm.doc.getLine(pos.line);\r\n      var info = mapFromLineView(view, line, pos.line);\r\n\r\n      var order = getOrder(line), side = \"left\";\r\n      if (order) {\r\n        var partPos = getBidiPartAt(order, pos.ch);\r\n        side = partPos % 2 ? \"right\" : \"left\";\r\n      }\r\n      var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\r\n      result.offset = result.collapse == \"right\" ? result.end : result.start;\r\n      return result;\r\n    },\r\n\r\n    domToPos : function (node, offset) {\r\n      var cm = this;\r\n\r\n      var lineNode;\r\n      if (node == cm.display.lineDiv) {\r\n        lineNode = cm.display.lineDiv.childNodes[offset];\r\n        if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\r\n        node = null; offset = 0;\r\n      } else {\r\n        for (lineNode = node;; lineNode = lineNode.parentNode) {\r\n          if (!lineNode || lineNode == cm.display.lineDiv) return null;\r\n          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\r\n        }\r\n      }\r\n      for (var i = 0; i < cm.display.view.length; i++) {\r\n        var lineView = cm.display.view[i];\r\n        if (lineView.node == lineNode)\r\n          return lineView.locateNodeInLineView(node, offset);\r\n      }\r\n    },\r\n\r\n    domTextBetween : function (from, to, fromLine, toLine) {\r\n      var cm = this;\r\n\r\n      var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\r\n      function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\r\n      function walk(node) {\r\n        if (node.nodeType == 1) {\r\n          var cmText = node.getAttribute(\"cm-text\");\r\n          if (cmText != null) {\r\n            if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\r\n            text += cmText;\r\n            return;\r\n          }\r\n          var markerID = node.getAttribute(\"cm-marker\"), range;\r\n          if (markerID) {\r\n            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\r\n            if (found.length && (range = found[0].find()))\r\n              text += getBetween(cm.doc, range.from, range.to).join(lineSep);\r\n            return;\r\n          }\r\n          if (node.getAttribute(\"contenteditable\") == \"false\") return;\r\n          for (var i = 0; i < node.childNodes.length; i++)\r\n            walk(node.childNodes[i]);\r\n          if (/^(pre|div|p)$/i.test(node.nodeName))\r\n            closing = true;\r\n        } else if (node.nodeType == 3) {\r\n          var val = node.nodeValue;\r\n          if (!val) return;\r\n          if (closing) {\r\n            text += lineSep;\r\n            closing = false;\r\n          }\r\n          text += val;\r\n        }\r\n      }\r\n      for (;;) {\r\n        walk(from);\r\n        if (from == to) break;\r\n        from = from.nextSibling;\r\n      }\r\n      return text;\r\n    }\r\n\r\n\r\n  });\r\n\r\n});\r\n"]}