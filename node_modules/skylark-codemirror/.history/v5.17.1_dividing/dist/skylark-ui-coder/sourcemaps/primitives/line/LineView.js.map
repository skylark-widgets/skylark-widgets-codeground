{"version":3,"sources":["primitives/line/LineView.js"],"names":["define","Evented","iherit","klassName","_construct","doc","line","lineN","this","rest","visualLineContinued","size","lineNo","lst","node","text","hidden","lineIsHidden","locateNodeInLineView","offset","find","textNode","topNode","i","maps","length","map","measure","j","curNode","lineView","ch","Pos","wrapper","firstChild","bad","contains","badPos","childNodes","nodeType","nodeValue","parentNode","found","after","nextSibling","dist","textContent","before","previousSibling"],"mappings":";;;;;;;AAAAA,QACE,yBACA,SAASC,GAIMA,EAAQC,QACtBC,UAAY,WAEXC,WAAa,SAASC,EAAKC,EAAMC,GAE/BC,KAAKF,KAAOA,EAEZE,KAAKC,KAAOC,oBAAoBJ,GAEhCE,KAAKG,KAAOH,KAAKC,KAAOG,OAAOC,IAAIL,KAAKC,OAASF,EAAQ,EAAI,EAC7DC,KAAKM,KAAON,KAAKO,KAAO,KACxBP,KAAKQ,OAASC,aAAaZ,EAAKC,IAGlCY,qBAAuB,SAAUJ,EAAMK,GAuBrC,QAASC,GAAKC,EAAUC,EAASH,GAC/B,IAAK,GAAII,MAAQA,GAAKC,EAAOA,EAAKC,OAAS,GAAIF,IAE7C,IAAK,GADDG,GAAMH,EAAI,EAAII,EAAQD,IAAMF,EAAKD,GAC5BK,EAAI,EAAGA,EAAIF,EAAID,OAAQG,GAAK,EAAG,CACtC,GAAIC,GAAUH,EAAIE,EAAI,EACtB,IAAIC,GAAWR,GAAYQ,GAAWP,EAAS,CAC7C,GAAIhB,GAAOM,OAAOW,EAAI,EAAIO,EAASxB,KAAOwB,EAASrB,KAAKc,IACpDQ,EAAKL,EAAIE,GAAKT,CAElB,QADIA,EAAS,GAAKU,GAAWR,KAAUU,EAAKL,EAAIE,GAAKT,EAAS,EAAI,KAC3Da,IAAI1B,EAAMyB,KA/BzB,GAAID,GAAWtB,KAEXyB,EAAUH,EAASf,KAAKmB,WAAYC,GAAM,CAC9C,KAAKrB,IAASsB,SAASH,EAASnB,GAAO,MAAOuB,QAAOL,IAAIpB,OAAOkB,EAASxB,MAAO,IAAI,EACpF,IAAIQ,GAAQmB,IACVE,GAAM,EACNrB,EAAOmB,EAAQK,WAAWnB,GAC1BA,EAAS,GACJL,GAAM,CACT,GAAIR,GAAOwB,EAASrB,KAAOI,IAAIiB,EAASrB,MAAQqB,EAASxB,IACzD,OAAO+B,QAAOL,IAAIpB,OAAON,GAAOA,EAAKS,KAAKU,QAASU,GAIvD,GAAId,GAA4B,GAAjBP,EAAKyB,SAAgBzB,EAAO,KAAMQ,EAAUR,CAK3D,KAJKO,GAAsC,GAA1BP,EAAKwB,WAAWb,QAA2C,GAA5BX,EAAKoB,WAAWK,WAC9DlB,EAAWP,EAAKoB,WACZf,IAAQA,EAASE,EAASmB,UAAUf,SAEnCH,EAAQmB,YAAcR,GAASX,EAAUA,EAAQmB,UACxD,IAAId,GAAUG,EAASH,QAASH,EAAOG,EAAQH,KAgB3CkB,EAAQtB,EAAKC,EAAUC,EAASH,EACpC,IAAIuB,EAAO,MAAOL,QAAOK,EAAOP,EAGhC,KAAK,GAAIQ,GAAQrB,EAAQsB,YAAaC,EAAOxB,EAAWA,EAASmB,UAAUf,OAASN,EAAS,EAAGwB,EAAOA,EAAQA,EAAMC,YAAa,CAEhI,GADAF,EAAQtB,EAAKuB,EAAOA,EAAMT,WAAY,GAEpC,MAAOG,QAAOL,IAAIU,EAAMpC,KAAMoC,EAAMX,GAAKc,GAAOV,EAEhDU,IAAQF,EAAMG,YAAYrB,OAE9B,IAAK,GAAIsB,GAASzB,EAAQ0B,gBAAiBH,EAAO1B,EAAQ4B,EAAQA,EAASA,EAAOC,gBAAiB,CAEjG,GADAN,EAAQtB,EAAK2B,EAAQA,EAAOb,eAE1B,MAAOG,QAAOL,IAAIU,EAAMpC,KAAMoC,EAAMX,GAAKc,GAAOV,EAEhDU,IAAQF,EAAMG,YAAYrB","file":"../../../primitives/line/LineView.js","sourcesContent":["define([\r\n  \"skylark-langx/Evented\",\r\n],function(Evented){\r\n  // These objects are used to represent the visible (currently drawn)\r\n  // part of the document. A LineView may correspond to multiple\r\n  // logical lines, if those are connected by collapsed ranges.\r\n  var LineView = Evented.iherit({\r\n  \tklassName : \"LineView\",\r\n  \t\r\n    _construct : function(doc, line, lineN) {\r\n      // The starting line\r\n      this.line = line;\r\n      // Continuing lines, if any\r\n      this.rest = visualLineContinued(line);\r\n      // Number of logical lines in this visual line\r\n      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n      this.node = this.text = null;\r\n      this.hidden = lineIsHidden(doc, line);      \r\n    },\r\n\r\n    locateNodeInLineView : function (node, offset) {\r\n      var lineView = this;\r\n      \r\n      var wrapper = lineView.text.firstChild, bad = false;\r\n      if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\r\n      if (node == wrapper) {\r\n        bad = true;\r\n        node = wrapper.childNodes[offset];\r\n        offset = 0;\r\n        if (!node) {\r\n          var line = lineView.rest ? lst(lineView.rest) : lineView.line;\r\n          return badPos(Pos(lineNo(line), line.text.length), bad);\r\n        }\r\n      }\r\n\r\n      var textNode = node.nodeType == 3 ? node : null, topNode = node;\r\n      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\r\n        textNode = node.firstChild;\r\n        if (offset) offset = textNode.nodeValue.length;\r\n      }\r\n      while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\r\n      var measure = lineView.measure, maps = measure.maps;\r\n\r\n      function find(textNode, topNode, offset) {\r\n        for (var i = -1; i < (maps ? maps.length : 0); i++) {\r\n          var map = i < 0 ? measure.map : maps[i];\r\n          for (var j = 0; j < map.length; j += 3) {\r\n            var curNode = map[j + 2];\r\n            if (curNode == textNode || curNode == topNode) {\r\n              var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\r\n              var ch = map[j] + offset;\r\n              if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\r\n              return Pos(line, ch);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      var found = find(textNode, topNode, offset);\r\n      if (found) return badPos(found, bad);\r\n\r\n      // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\r\n      for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\r\n        found = find(after, after.firstChild, 0);\r\n        if (found)\r\n          return badPos(Pos(found.line, found.ch - dist), bad);\r\n        else\r\n          dist += after.textContent.length;\r\n      }\r\n      for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\r\n        found = find(before, before.firstChild, -1);\r\n        if (found)\r\n          return badPos(Pos(found.line, found.ch + dist), bad);\r\n        else\r\n          dist += after.textContent.length;\r\n      }\r\n    }\r\n   \r\n  });\r\n});"]}