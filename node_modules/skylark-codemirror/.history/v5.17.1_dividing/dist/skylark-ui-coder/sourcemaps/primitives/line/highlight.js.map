{"version":3,"sources":["primitives/line/highlight.js"],"names":["define","CoderCtor","readToken","mode","stream","state","inner","i","CodeMirror","innerMode","style","token","pos","start","Error","name","runMode","cm","text","f","lineClasses","forceToEnd","flattenSpans","options","curStart","curStyle","StringStream","tabSize","addModeClass","extractLineClasses","callBlankLine","eol","maxHighlightLength","processLine","length","mName","Math","min","partial","findStartLine","n","precise","minindent","minline","this","doc","lim","search","first","line","getLine","stateAfter","frontier","indented","countColumn","highlightLine","st","modeGen","end","push","o","overlays","overlay","at","i_end","splice","opaque","cur","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getStateBefore","lineNo","result","copyState","styleClasses","startAt"],"mappings":"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","file":"../../../primitives/line/highlight.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n \r\n  CoderCtor.partial({\r\n    // Finds the line to start with when starting a parse. Tries to\r\n    // find a line with a stateAfter, so that it can start with a\r\n    // valid state. If that fails, it returns the line with the\r\n    // smallest indentation, which tends to need the least context to\r\n    // parse correctly.\r\n    findStartLine : function(n, precise) {\r\n      var cm = this;\r\n\r\n      var minindent, minline, doc = cm.doc;\r\n      var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n      for (var search = n; search > lim; --search) {\r\n        if (search <= doc.first) return doc.first;\r\n        var line = getLine(doc, search - 1);\r\n        if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\r\n        var indented = countColumn(line.text, null, cm.options.tabSize);\r\n        if (minline == null || minindent > indented) {\r\n          minline = search - 1;\r\n          minindent = indented;\r\n        }\r\n      }\r\n      return minline;\r\n    },\r\n\r\n\r\n    // Compute a style array (an array starting with a mode generation\r\n    // -- for invalidation -- followed by pairs of end positions and\r\n    // style strings), which is used to highlight the tokens on the\r\n    // line.\r\n    highlightLine : function (line, state, forceToEnd) {\r\n      var cm = this;\r\n\r\n      // A styles array always starts with a number identifying the\r\n      // mode/overlays that it is based on (for easy invalidation).\r\n      var st = [cm.state.modeGen], lineClasses = {};\r\n      // Compute the base array of styles\r\n      runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\r\n        st.push(end, style);\r\n      }, lineClasses, forceToEnd);\r\n\r\n      // Run overlays, adjust style array.\r\n      for (var o = 0; o < cm.state.overlays.length; ++o) {\r\n        var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n        runMode(cm, line.text, overlay.mode, true, function(end, style) {\r\n          var start = i;\r\n          // Ensure there's a token end at the current position, and that i points at it\r\n          while (at < end) {\r\n            var i_end = st[i];\r\n            if (i_end > end)\r\n              st.splice(i, 1, end, st[i+1], i_end);\r\n            i += 2;\r\n            at = Math.min(end, i_end);\r\n          }\r\n          if (!style) return;\r\n          if (overlay.opaque) {\r\n            st.splice(start, i - start, end, \"cm-overlay \" + style);\r\n            i = start + 2;\r\n          } else {\r\n            for (; start < i; start += 2) {\r\n              var cur = st[start+1];\r\n              st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\r\n            }\r\n          }\r\n        }, lineClasses);\r\n      }\r\n\r\n      return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\r\n    },\r\n\r\n\r\n    getLineStyles : function (line, updateFrontier) {\r\n      var cm = this;\r\n\r\n      if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n        var state = cm.getStateBefore(lineNo(line));\r\n        var result = cm.highlightLine(line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\r\n        line.stateAfter = state;\r\n        line.styles = result.styles;\r\n        if (result.classes) line.styleClasses = result.classes;\r\n        else if (line.styleClasses) line.styleClasses = null;\r\n        if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\r\n      }\r\n      return line.styles;\r\n    },\r\n\r\n    // Lightweight form of highlight -- proceed over this line and\r\n    // update state, but don't save a style array. Used for lines that\r\n    // aren't currently visible.\r\n    processLine : function (text, state, startAt) {\r\n      var cm = this;\r\n\r\n      var mode = cm.doc.mode;\r\n      var stream = new StringStream(text, cm.options.tabSize);\r\n      stream.start = stream.pos = startAt || 0;\r\n      if (text == \"\") {\r\n        callBlankLine(mode, state);\r\n      }\r\n      while (!stream.eol()) {\r\n        readToken(mode, stream, state);\r\n        stream.start = stream.pos;\r\n      }\r\n    }\r\n  });\r\n\r\n  function readToken(mode, stream, state, inner) {\r\n    for (var i = 0; i < 10; i++) {\r\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\r\n      var style = mode.token(stream, state);\r\n      if (stream.pos > stream.start) return style;\r\n    }\r\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\r\n  }\r\n\r\n  // Utility for getTokenAt and getLineTokens\r\n  function takeToken(cm, pos, precise, asArray) {\r\n    function getObj(copy) {\r\n      return {start: stream.start, end: stream.pos,\r\n              string: stream.current(),\r\n              type: style || null,\r\n              state: copy ? copyState(doc.mode, state) : state};\r\n    }\r\n\r\n    var doc = cm.doc, mode = doc.mode, style;\r\n    pos = clipPos(doc, pos);\r\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\r\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\r\n    if (asArray) tokens = [];\r\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\r\n      stream.start = stream.pos;\r\n      style = readToken(mode, stream, state);\r\n      if (asArray) tokens.push(getObj(true));\r\n    }\r\n    return asArray ? tokens : getObj();\r\n  }\r\n\r\n // Run the given mode's parser over a line, calling f for each token.\r\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\r\n    var flattenSpans = mode.flattenSpans;\r\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\r\n    var curStart = 0, curStyle = null;\r\n    var stream = new StringStream(text, cm.options.tabSize), style;\r\n    var inner = cm.options.addModeClass && [null];\r\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\r\n    while (!stream.eol()) {\r\n      if (stream.pos > cm.options.maxHighlightLength) {\r\n        flattenSpans = false;\r\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\r\n        stream.pos = text.length;\r\n        style = null;\r\n      } else {\r\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\r\n      }\r\n      if (inner) {\r\n        var mName = inner[0].name;\r\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\r\n      }\r\n      if (!flattenSpans || curStyle != style) {\r\n        while (curStart < stream.start) {\r\n          curStart = Math.min(stream.start, curStart + 50000);\r\n          f(curStart, curStyle);\r\n        }\r\n        curStyle = style;\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n    while (curStart < stream.pos) {\r\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\r\n      var pos = Math.min(stream.pos, curStart + 50000);\r\n      f(pos, curStyle);\r\n      curStart = pos;\r\n    }\r\n  }\r\n\r\n\r\n});\r\n"]}