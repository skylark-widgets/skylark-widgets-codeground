{"version":3,"sources":["primitives/line/line_data.js"],"names":["define","CoderCtor","interpretTokenStyle","style","options","test","cache","addModeClass","styleToClassCacheWithMode","styleToClassCache","replace","buildToken","builder","text","startStyle","endStyle","title","css","displayText","splitSpaces","trailingSpace","special","cm","state","specialChars","mustWrap","content","document","createDocumentFragment","pos","lastIndex","m","exec","skipped","index","length","txt","createTextNode","slice","ie","ie_version","appendChild","elt","map","push","col","tabSize","tabWidth","spaceStr","setAttribute","specialCharPlaceholder","charCodeAt","fullStyle","token","trailingBefore","spaceBefore","result","i","ch","charAt","buildTokenBadBidi","inner","order","start","end","part","to","from","buildCollapsedSpan","size","marker","ignoreWidget","widget","widgetNode","display","input","needsContentAttribute","createElement","id","setUneditable","insertLineContent","line","styles","spans","markedSpans","allText","at","spanStyle","spanEndStyle","spanStartStyle","collapsed","len","nextChange","Infinity","endStyles","foundBookmarks","j","sp","type","className","compareCollapsedMarkers","upto","Math","min","tokenText","addToken","partial","buildViewArray","nextPos","this","array","view","LineView","doc","getLine","buildLineContent","lineView","webkit","pre","getOption","measure","rest","hasBadBidiRects","getOrder","allowFrontierUpdate","externalMeasured","lineNo","getLineStyles","styleClasses","bgClass","joinClasses","textClass","zeroWidthElement","maps","caches","last","lastChild","querySeleCoderCtor","signal"],"mappings":"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","file":"../../../primitives/line/line_data.js","sourcesContent":["define([\r\n  \"skylark-langx/klass\",\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  // VIEW TRACKING\r\n\r\n\r\n  CoderCtor.partial({\r\n    // Create a range of LineView objects for the given lines.\r\n    buildViewArray : function (from, to) {\r\n      var cm = this;\r\n\r\n      var array = [], nextPos;\r\n      for (var pos = from; pos < to; pos = nextPos) {\r\n        var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n        nextPos = pos + view.size;\r\n        array.push(view);\r\n      }\r\n      return array;\r\n    },\r\n\r\n    // Render the DOM representation of the text of a line. Also builds\r\n    // up a 'line map', which points at the DOM nodes that represent\r\n    // specific stretches of text, and is used by the measuring code.\r\n    // The returned object contains the DOM node, this map, and\r\n    // information about line-wide styles that were set by the mode.\r\n    buildLineContent : function (cm, lineView) {\r\n      // The padding-right forces the element to have a 'border', which\r\n      // is needed on Webkit to be able to get line-level bounding\r\n      // rectangles for it (in measureChar).\r\n      var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\r\n      var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\r\n                     col: 0, pos: 0, cm: cm,\r\n                     trailingSpace: false,\r\n                     splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\r\n      lineView.measure = {};\r\n\r\n      // Iterate over the logical lines that make up this visual line.\r\n      for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n        var line = i ? lineView.rest[i - 1] : lineView.line, order;\r\n        builder.pos = 0;\r\n        builder.addToken = buildToken;\r\n        // Optionally wire in some hacks into the token-rendering\r\n        // algorithm, to deal with browser quirks.\r\n        if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\r\n          builder.addToken = buildTokenBadBidi(builder.addToken, order);\r\n        builder.map = [];\r\n        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\r\n        insertLineContent(line, builder, cm.getLineStyles(line, allowFrontierUpdate));\r\n        if (line.styleClasses) {\r\n          if (line.styleClasses.bgClass)\r\n            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\r\n          if (line.styleClasses.textClass)\r\n            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\r\n        }\r\n\r\n        // Ensure at least a single node is present, for measuring.\r\n        if (builder.map.length == 0) {\r\n          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\r\n        }\r\n\r\n        // Store the map and a cache object for the current logical line\r\n        if (i == 0) {\r\n          lineView.measure.map = builder.map;\r\n          lineView.measure.cache = {};\r\n        } else {\r\n          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\r\n          (lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n        }\r\n      }\r\n\r\n      // See issue #2901\r\n      if (webkit) {\r\n        var last = builder.content.lastChild\r\n        if (/\\bcm-tab\\b/.test(last.className) || (last.querySeleCoderCtor && last.querySeleCoderCtor(\".cm-tab\")))\r\n          builder.content.className = \"cm-tab-wrap-hack\";\r\n      }\r\n\r\n      signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\r\n      if (builder.pre.className)\r\n        builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\r\n\r\n      return builder;\r\n    }\r\n  });\r\n\r\n  // Convert a style as returned by a mode (either null, or a string\r\n  // containing one or more styles) to a CSS style. This is cached,\r\n  // and also looks for line-wide styles.\r\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\r\n  function interpretTokenStyle(style, options) {\r\n    if (!style || /^\\s*$/.test(style)) return null;\r\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n    return cache[style] ||\r\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\r\n  }\r\n\r\n\r\n  function defaultSpecialCharPlaceholder(ch) {\r\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\r\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\r\n    token.setAttribute(\"aria-label\", token.title);\r\n    return token;\r\n  }\r\n\r\n  // Build up the DOM representation for a single token, and add it to\r\n  // the line map. Takes care to render special characters separately.\r\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\r\n    if (!text) return;\r\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\r\n    var special = builder.cm.state.specialChars, mustWrap = false;\r\n    if (!special.test(text)) {\r\n      builder.col += text.length;\r\n      var content = document.createTextNode(displayText);\r\n      builder.map.push(builder.pos, builder.pos + text.length, content);\r\n      if (ie && ie_version < 9) mustWrap = true;\r\n      builder.pos += text.length;\r\n    } else {\r\n      var content = document.createDocumentFragment(), pos = 0;\r\n      while (true) {\r\n        special.lastIndex = pos;\r\n        var m = special.exec(text);\r\n        var skipped = m ? m.index - pos : text.length - pos;\r\n        if (skipped) {\r\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\r\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n          builder.col += skipped;\r\n          builder.pos += skipped;\r\n        }\r\n        if (!m) break;\r\n        pos += skipped + 1;\r\n        if (m[0] == \"\\t\") {\r\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\r\n          txt.setAttribute(\"role\", \"presentation\");\r\n          txt.setAttribute(\"cm-text\", \"\\t\");\r\n          builder.col += tabWidth;\r\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\r\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\r\n          txt.setAttribute(\"cm-text\", m[0]);\r\n          builder.col += 1;\r\n        } else {\r\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\r\n          txt.setAttribute(\"cm-text\", m[0]);\r\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.col += 1;\r\n        }\r\n        builder.map.push(builder.pos, builder.pos + 1, txt);\r\n        builder.pos++;\r\n      }\r\n    }\r\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\r\n    if (style || startStyle || endStyle || mustWrap || css) {\r\n      var fullStyle = style || \"\";\r\n      if (startStyle) fullStyle += startStyle;\r\n      if (endStyle) fullStyle += endStyle;\r\n      var token = elt(\"span\", [content], fullStyle, css);\r\n      if (title) token.title = title;\r\n      return builder.content.appendChild(token);\r\n    }\r\n    builder.content.appendChild(content);\r\n  }\r\n\r\n  function splitSpaces(text, trailingBefore) {\r\n    if (text.length > 1 && !/  /.test(text)) return text\r\n    var spaceBefore = trailingBefore, result = \"\"\r\n    for (var i = 0; i < text.length; i++) {\r\n      var ch = text.charAt(i)\r\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\r\n        ch = \"\\u00a0\"\r\n      result += ch\r\n      spaceBefore = ch == \" \"\r\n    }\r\n    return result\r\n  }\r\n\r\n  // Work around nonsense dimensions being reported for stretches of\r\n  // right-to-left text.\r\n  function buildTokenBadBidi(inner, order) {\r\n    return function(builder, text, style, startStyle, endStyle, title, css) {\r\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\r\n      var start = builder.pos, end = start + text.length;\r\n      for (;;) {\r\n        // Find the part that overlaps with the start of this text\r\n        for (var i = 0; i < order.length; i++) {\r\n          var part = order[i];\r\n          if (part.to > start && part.from <= start) break;\r\n        }\r\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\r\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\r\n        startStyle = null;\r\n        text = text.slice(part.to - start);\r\n        start = part.to;\r\n      }\r\n    };\r\n  }\r\n\r\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n    var widget = !ignoreWidget && marker.widgetNode;\r\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\r\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\r\n      if (!widget)\r\n        widget = builder.content.appendChild(document.createElement(\"span\"));\r\n      widget.setAttribute(\"cm-marker\", marker.id);\r\n    }\r\n    if (widget) {\r\n      builder.cm.display.input.setUneditable(widget);\r\n      builder.content.appendChild(widget);\r\n    }\r\n    builder.pos += size;\r\n    builder.trailingSpace = false\r\n  }\r\n\r\n  // Outputs a number of spans to make up a line, taking highlighting\r\n  // and marked text into account.\r\n  function insertLineContent(line, builder, styles) {\r\n    var spans = line.markedSpans, allText = line.text, at = 0;\r\n    if (!spans) {\r\n      for (var i = 1; i < styles.length; i+=2)\r\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\r\n      return;\r\n    }\r\n\r\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\r\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\r\n    for (;;) {\r\n      if (nextChange == pos) { // Update current marker set\r\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\r\n        collapsed = null; nextChange = Infinity;\r\n        var foundBookmarks = [], endStyles\r\n        for (var j = 0; j < spans.length; ++j) {\r\n          var sp = spans[j], m = sp.marker;\r\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\r\n            foundBookmarks.push(m);\r\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\r\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\r\n              nextChange = sp.to;\r\n              spanEndStyle = \"\";\r\n            }\r\n            if (m.className) spanStyle += \" \" + m.className;\r\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\r\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\r\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\r\n            if (m.title && !title) title = m.title;\r\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n              collapsed = sp;\r\n          } else if (sp.from > pos && nextChange > sp.from) {\r\n            nextChange = sp.from;\r\n          }\r\n        }\r\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\r\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\r\n\r\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\r\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\r\n        if (collapsed && (collapsed.from || 0) == pos) {\r\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                             collapsed.marker, collapsed.from == null);\r\n          if (collapsed.to == null) return;\r\n          if (collapsed.to == pos) collapsed = false;\r\n        }\r\n      }\r\n      if (pos >= len) break;\r\n\r\n      var upto = Math.min(len, nextChange);\r\n      while (true) {\r\n        if (text) {\r\n          var end = pos + text.length;\r\n          if (!collapsed) {\r\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\r\n          }\r\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\r\n          pos = end;\r\n          spanStartStyle = \"\";\r\n        }\r\n        text = allText.slice(at, at = styles[i++]);\r\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n});\r\n"]}