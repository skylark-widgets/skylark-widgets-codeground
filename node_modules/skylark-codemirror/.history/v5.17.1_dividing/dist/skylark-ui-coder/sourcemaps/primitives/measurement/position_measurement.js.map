{"version":3,"sources":["primitives/measurement/position_measurement.js"],"names":["define","CoderCtor","mapFromLineView","lineView","line","lineN","map","measure","cache","i","rest","length","maps","caches","lineNo","before","nodeAndOffsetInLineMap","ch","bias","node","start","end","collapse","mStart","mEnd","insertLeft","coverStart","coverEnd","getUsefulRect","rects","rect","nullRect","left","right","maybeUpdateRectForZooming","window","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","top","bottom","clearLineMeasurementCacheFor","heights","pageScrollX","pageXOffset","document","documentElement","body","scrollLeft","pageScrollY","pageYOffset","scrollTop","PosWithInfo","outside","xRel","pos","Pos","partial","getDimensions","cm","this","d","display","width","gutterLeft","gutters","clientLeft","n","firstChild","nextSibling","options","offsetLeft","clientWidth","fixedPos","compensateForHScroll","gutterTotalWidth","offsetWidth","gutterWidth","wrapperWidth","wrapper","scrollGap","scrollerGap","nativeBarWidth","displayWidth","scroller","barWidth","displayHeight","clientHeight","barHeight","ensureLineHeights","wrapping","lineWrapping","curWidth","text","getClientRects","cur","next","Math","abs","push","updateExternalMeasurement","visualLine","view","externalMeasured","LineView","doc","built","buildLineContent","pre","removeChildrenAndAdd","lineMeasure","measureChar","measureCharPrepared","prepareMeasureForLine","findViewForLine","viewFrom","viewTo","findViewIndex","ext","size","changes","updateLineForChanges","curOp","forceUpdate","info","hasHeights","prepared","varHeight","found","key","hasOwnProperty","getBoundingClientRect","measureCharInner","bogus","rtop","rbottom","place","nodeType","isExtendingChar","charAt","ie","ie_version","parentNode","range","rSpan","charWidth","rbot","mid","bot","result","singleCursorHeightPerLine","clearLineMeasurementCache","externalMeasure","removeChildren","clearCaches","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLineChanged","lineNumChars","intoCoordSystem","lineObj","context","widgets","above","widgetHeight","yOff","heightAtLine","paddingTop","viewOffset","lOff","lineSpace","xOff","fromCoordSystem","coords","localBox","sizer","lineSpaceBox","coordsChar","x","y","first","lineAtHeight","last","getLine","coordsCharInner","merged","collapsedSpanAtEnd","mergedPos","find","from","to","getX","sp","cursorCoords","preparedMeasure","wrongLine","innerOff","adjust","bidi","getOrder","dist","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","test","charSize","step","ceil","middle","middleX","posFromMouse","e","liberal","forRect","e_target","getAttribute","space","clientX","clientY","colDiff","countColumn","tabSize","max","round","paddingH","estimateHeight","th","textHeight","perLine","lineIsHidden","widgetsHeight","height","estimateLineHeights","est","iter","estHeight","updateLineHeight"],"mappings":"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","file":"../../../primitives/measurement/position_measurement.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n\r\n    CoderCtor.partial({\r\n      // Do a bulk-read of the DOM positions and sizes needed to draw the\r\n      // view, so that we don't interleave reading and writing to the DOM.\r\n      getDimensions : function () {\r\n        var cm = this;\r\n\r\n        var d = cm.display, left = {}, width = {};\r\n\r\n        var gutterLeft = d.gutters.clientLeft;\r\n\r\n        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n          left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\r\n          width[cm.options.gutters[i]] = n.clientWidth;\r\n        }\r\n\r\n        return {\r\n          fixedPos: compensateForHScroll(d),\r\n          gutterTotalWidth: d.gutters.offsetWidth,\r\n          gutterLeft: left,\r\n          gutterWidth: width,\r\n          wrapperWidth: d.wrapper.clientWidth\r\n        };\r\n      },\r\n\r\n      scrollGap : function () { \r\n        var cm = this;\r\n\r\n        return scrollerGap - cm.display.nativeBarWidth; \r\n      },\r\n      \r\n      displayWidth : function () {\r\n        var cm = this;\r\n\r\n        return cm.display.scroller.clientWidth - cm.scrollGap() - cm.display.barWidth;\r\n      },\r\n\r\n      displayHeight : function () {\r\n        var cm = this;\r\n\r\n        return cm.display.scroller.clientHeight - cm.scrollGap() - cm.display.barHeight;\r\n      },\r\n\r\n      // Ensure the lineView.wrapping.heights array is populated. This is\r\n      // an array of bottom offsets for the lines that make up a drawn\r\n      // line. When lineWrapping is on, there might be more than one\r\n      // height.\r\n      ensureLineHeights : function ( lineView, rect) {\r\n        var cm = this;\r\n\r\n        var wrapping = cm.options.lineWrapping;\r\n        var curWidth = wrapping && cm.displayWidth();\r\n        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n          var heights = lineView.measure.heights = [];\r\n          if (wrapping) {\r\n            lineView.measure.width = curWidth;\r\n            var rects = lineView.text.firstChild.getClientRects();\r\n            for (var i = 0; i < rects.length - 1; i++) {\r\n              var cur = rects[i], next = rects[i + 1];\r\n              if (Math.abs(cur.bottom - next.bottom) > 2)\r\n                heights.push((cur.bottom + next.top) / 2 - rect.top);\r\n            }\r\n          }\r\n          heights.push(rect.bottom - rect.top);\r\n        }\r\n      },\r\n\r\n      // Render a line into the hidden node display.externalMeasured. Used\r\n      // when measurement is needed for a line that's not in the viewport.\r\n      updateExternalMeasurement : function (line) {\r\n        var cm = this;\r\n\r\n        line = visualLine(line);\r\n        var lineN = line.lineNo();\r\n\r\n        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n\r\n        view.lineN = lineN;\r\n        var built = view.built = cm.buildLineContent(view);\r\n\r\n        view.text = built.pre;\r\n        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n\r\n        return view;\r\n      },\r\n\r\n      // Get a {top, bottom, left, right} box (in line-local coordinates)\r\n      // for a given character.\r\n     measureChar :  function (line, ch, bias) {\r\n        var cm = this;\r\n\r\n        return cm.measureCharPrepared(cm.prepareMeasureForLine(line), ch, bias);\r\n      },\r\n\r\n      // Find a line view that corresponds to the given line number.\r\n      findViewForLine : function (lineN) {\r\n        var cm = this;\r\n\r\n        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n          return cm.display.view[findViewIndex(cm, lineN)];\r\n        var ext = cm.display.externalMeasured;\r\n        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n          return ext;\r\n      },\r\n\r\n      // Measurement can be split in two steps, the set-up work that\r\n      // applies to the whole line, and the measurement of the actual\r\n      // character. Functions like coordsChar, that need to do a lot of\r\n      // measurements in a row, can thus ensure that the set-up work is\r\n      // only done once.\r\n      prepareMeasureForLine : function (line) {\r\n        var cm = this;\r\n\r\n        var lineN = line.lineNo();\r\n\r\n        var view = cm.findViewForLine(lineN);\r\n\r\n        if (view && !view.text) {\r\n          view = null;\r\n        } else if (view && view.changes) {\r\n          cm.updateLineForChanges(view, lineN, cm.getDimensions());\r\n          cm.curOp.forceUpdate = true;\r\n        }\r\n        if (!view) {\r\n          view = cm.updateExternalMeasurement(line);\r\n        }\r\n\r\n        var info = mapFromLineView(view, line, lineN);\r\n\r\n        return {\r\n          line: line, \r\n          view: view, \r\n          rect: null,\r\n          map: info.map, \r\n          cache: info.cache, \r\n          before: info.before,\r\n          hasHeights: false\r\n        };\r\n      },\r\n\r\n      // Given a prepared measurement object, measures the position of an\r\n      // actual character (or fetches it from the cache).\r\n      measureCharPrepared : function (prepared, ch, bias, varHeight) {\r\n        var cm = this;\r\n\r\n        if (prepared.before) ch = -1;\r\n        var key = ch + (bias || \"\"), found;\r\n        if (prepared.cache.hasOwnProperty(key)) {\r\n          found = prepared.cache[key];\r\n        } else {\r\n          if (!prepared.rect)\r\n            prepared.rect = prepared.view.text.getBoundingClientRect();\r\n          if (!prepared.hasHeights) {\r\n            cm.ensureLineHeights(prepared.view, prepared.rect);\r\n            prepared.hasHeights = true;\r\n          }\r\n          found = cm.measureCharInner(prepared, ch, bias);\r\n          if (!found.bogus) {\r\n            prepared.cache[key] = found;\r\n          }\r\n        }\r\n\r\n        return {\r\n          left: found.left, \r\n          right: found.right,\r\n          top: varHeight ? found.rtop : found.top,\r\n          bottom: varHeight ? found.rbottom : found.bottom\r\n        };\r\n      },\r\n\r\n      measureCharInner : function (prepared, ch, bias) {\r\n        var cm = this;\r\n\r\n        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\r\n\r\n        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\r\n\r\n        var rect;\r\n        if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n          for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\r\n            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\r\n            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\r\n              rect = node.parentNode.getBoundingClientRect();\r\n            else\r\n              rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\r\n            if (rect.left || rect.right || start == 0) break;\r\n            end = start;\r\n            start = start - 1;\r\n            collapse = \"right\";\r\n          }\r\n          if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\r\n        } else { // If it is a widget, simply get the box for the whole widget.\r\n          if (start > 0) collapse = bias = \"right\";\r\n          var rects;\r\n          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n            rect = rects[bias == \"right\" ? rects.length - 1 : 0];\r\n          else\r\n            rect = node.getBoundingClientRect();\r\n        }\r\n        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n          var rSpan = node.parentNode.getClientRects()[0];\r\n          if (rSpan) {\r\n            rect = {\r\n              left: rSpan.left, \r\n              right: rSpan.left + charWidth(cm.display), \r\n              top: rSpan.top, \r\n              bottom: rSpan.bottom};\r\n          } else {\r\n            rect = nullRect;\r\n          }\r\n        }\r\n\r\n        var rtop = rect.top - prepared.rect.top, \r\n            rbot = rect.bottom - prepared.rect.top;\r\n        \r\n        var mid = (rtop + rbot) / 2;\r\n        \r\n        var heights = prepared.view.measure.heights;\r\n        \r\n        for (var i = 0; i < heights.length - 1; i++)\r\n          if (mid < heights[i]) break;\r\n        \r\n        var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n        \r\n        var result = {\r\n          left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\r\n          right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\r\n          top: top, \r\n          bottom: bot\r\n        };\r\n        \r\n        if (!rect.left && !rect.right) {\r\n          result.bogus = true;\r\n        }\r\n        \r\n        if (!cm.options.singleCursorHeightPerLine) { \r\n          result.rtop = rtop; \r\n          result.rbottom = rbot; \r\n        }\r\n\r\n        return result;\r\n      },\r\n\r\n      clearLineMeasurementCache : function (cm) {\r\n        var cm = this;\r\n\r\n        cm.display.externalMeasure = null;\r\n        \r\n        removeChildren(cm.display.lineMeasure);\r\n        \r\n        for (var i = 0; i < cm.display.view.length; i++) {\r\n          clearLineMeasurementCacheFor(cm.display.view[i]);\r\n        }\r\n      },\r\n\r\n      clearCaches : function () {\r\n        var cm = this;\r\n\r\n        clearLineMeasurementCache(cm);\r\n        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n        if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\r\n        cm.display.lineNumChars = null;\r\n      },\r\n\r\n      // Converts a {top, bottom, left, right} box from line-local\r\n      // coordinates into another coordinate system. Context may be one of\r\n      // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\r\n      // or \"page\".\r\n      intoCoordSystem : function (lineObj, rect, context) {\r\n        var cm = this;\r\n\r\n        if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\r\n          var size = widgetHeight(lineObj.widgets[i]);\r\n          rect.top += size; rect.bottom += size;\r\n        }\r\n        if (context == \"line\") return rect;\r\n        if (!context) context = \"local\";\r\n        var yOff = heightAtLine(lineObj);\r\n        if (context == \"local\") yOff += paddingTop(cm.display);\r\n        else yOff -= cm.display.viewOffset;\r\n        if (context == \"page\" || context == \"window\") {\r\n          var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n          yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\r\n          var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\r\n          rect.left += xOff; rect.right += xOff;\r\n        }\r\n        rect.top += yOff; \r\n        rect.bottom += yOff;\r\n        return rect;\r\n      },\r\n\r\n      // Coverts a box from \"div\" coords to another coordinate system.\r\n      // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\r\n      fromCoordSystem : function (coords, context) {\r\n        var cm = this;\r\n\r\n        if (context == \"div\") return coords;\r\n        var left = coords.left, top = coords.top;\r\n        // First move into \"page\" coordinate system\r\n        if (context == \"page\") {\r\n          left -= pageScrollX();\r\n          top -= pageScrollY();\r\n        } else if (context == \"local\" || !context) {\r\n          var localBox = cm.display.sizer.getBoundingClientRect();\r\n          left += localBox.left;\r\n          top += localBox.top;\r\n        }\r\n\r\n        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n        return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\r\n      },\r\n\r\n      // Compute the character position closest to the given coordinates.\r\n      // Input must be lineSpace-local (\"div\" coordinate system).\r\n      coordsChar : function (x, y) {\r\n        var cm = this;\r\n\r\n        var doc = cm.doc;\r\n        y += cm.display.viewOffset;\r\n        if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\r\n        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n        if (lineN > last)\r\n          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\r\n        if (x < 0) x = 0;\r\n\r\n        var lineObj = getLine(doc, lineN);\r\n        for (;;) {\r\n          var found = cm.coordsCharInner(lineObj, lineN, x, y);\r\n          var merged = collapsedSpanAtEnd(lineObj);\r\n          var mergedPos = merged && merged.find(0, true);\r\n          if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\r\n            lineN = lineNo(lineObj = mergedPos.to.line);\r\n          else\r\n            return found;\r\n        }\r\n      },\r\n\r\n      coordsCharInner : function (lineObj, lineNo, x, y) {\r\n        var cm = this;\r\n\r\n        var innerOff = y - heightAtLine(lineObj);\r\n        var wrongLine = false, \r\n            adjust = 2 * cm.display.wrapper.clientWidth;\r\n        var preparedMeasure = cm.prepareMeasureForLine(lineObj);\r\n\r\n        function getX(ch) {\r\n          var sp = cm.cursorCoords(Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\r\n          wrongLine = true;\r\n          if (innerOff > sp.bottom) return sp.left - adjust;\r\n          else if (innerOff < sp.top) return sp.left + adjust;\r\n          else wrongLine = false;\r\n          return sp.left;\r\n        }\r\n\r\n        var bidi = getOrder(lineObj), dist = lineObj.text.length;\r\n        var from = lineLeft(lineObj), to = lineRight(lineObj);\r\n        var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\r\n\r\n        if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\r\n        // Do a binary search between these bounds.\r\n        for (;;) {\r\n          if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\r\n            var ch = x < fromX || x - fromX <= toX - x ? from : to;\r\n            var outside = ch == from ? fromOutside : toOutside\r\n            var xDiff = x - (ch == from ? fromX : toX);\r\n            // This is a kludge to handle the case where the coordinates\r\n            // are after a line-wrapped line. We should replace it with a\r\n            // more general handling of cursor positions around line\r\n            // breaks. (Issue #4078)\r\n            if (toOutside && !bidi && !/\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\r\n                ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\r\n              var charSize = measureCharPrepared(cm, preparedMeasure, ch, \"right\");\r\n              if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\r\n                outside = false\r\n                ch++\r\n                xDiff = x - charSize.right\r\n              }\r\n            }\r\n            while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\r\n            var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\r\n            return pos;\r\n          }\r\n          var step = Math.ceil(dist / 2), middle = from + step;\r\n          if (bidi) {\r\n            middle = from;\r\n            for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\r\n          }\r\n          var middleX = getX(middle);\r\n          if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\r\n          else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\r\n        }\r\n      },\r\n\r\n      // Given a mouse event, find the corresponding position. If liberal\r\n      // is false, it checks whether a gutter or scrollbar was clicked,\r\n      // and returns null if it was. forRect is used by rectangular\r\n      // selections, and tries to estimate a character position even for\r\n      // coordinates beyond the right of the text.\r\n      posFromMouse : function (e, liberal, forRect) {\r\n        var cm = this;\r\n\r\n        var display = cm.display;\r\n        if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\r\n\r\n        var x, y, space = display.lineSpace.getBoundingClientRect();\r\n        // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n        try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n        catch (e) { return null; }\r\n        var coords = coordsChar(cm, x, y), line;\r\n        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n        }\r\n        return coords;\r\n      },\r\n\r\n      // Returns a function that estimates the height of a line, to use as\r\n      // first approximation until the line becomes visible (and is thus\r\n      // properly measurable).\r\n      estimateHeight : function () {\r\n        var cm = this;\r\n\r\n        var th = cm.display.textHeight(), \r\n            wrapping = cm.options.lineWrapping;\r\n\r\n        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n\r\n        return function(line) {\r\n          if (lineIsHidden(cm.doc, line)) return 0;\r\n\r\n          var widgetsHeight = 0;\r\n          if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\r\n            if (line.widgets[i].height) {\r\n              widgetsHeight += line.widgets[i].height;\r\n            }\r\n          }\r\n\r\n          if (wrapping){\r\n            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\r\n          } else {\r\n            return widgetsHeight + th;\r\n          }\r\n        };\r\n      },\r\n\r\n      estimateLineHeights : function () {\r\n        var cm = this;\r\n\r\n        var doc = cm.doc, \r\n            est = cm.estimateHeight();\r\n\r\n        doc.iter(function(line) {\r\n          var estHeight = est(line);\r\n          if (estHeight != line.height) {\r\n            updateLineHeight(line, estHeight);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n\r\n  // POSITION MEASUREMENT\r\n\r\n\r\n\r\n\r\n  // Find a line map (mapping character offsets to text nodes) and a\r\n  // measurement cache for the given line number. (A line view might\r\n  // contain multiple lines when collapsed ranges are present.)\r\n  function mapFromLineView(lineView, line, lineN) {\r\n    if (lineView.line == line)\r\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineView.rest[i] == line)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineNo(lineView.rest[i]) > lineN)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\r\n  }\r\n\r\n\r\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\n  function nodeAndOffsetInLineMap(map, ch, bias) {\r\n    var node, start, end, collapse;\r\n    // First, search the line map for the text node corresponding to,\r\n    // or closest to, the target character.\r\n    for (var i = 0; i < map.length; i += 3) {\r\n      var mStart = map[i], mEnd = map[i + 1];\r\n      if (ch < mStart) {\r\n        start = 0; end = 1;\r\n        collapse = \"left\";\r\n      } else if (ch < mEnd) {\r\n        start = ch - mStart;\r\n        end = start + 1;\r\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\r\n        end = mEnd - mStart;\r\n        start = end - 1;\r\n        if (ch >= mEnd) collapse = \"right\";\r\n      }\r\n      if (start != null) {\r\n        node = map[i + 2];\r\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\r\n          collapse = bias;\r\n        if (bias == \"left\" && start == 0)\r\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\r\n            node = map[(i -= 3) + 2];\r\n            collapse = \"left\";\r\n          }\r\n        if (bias == \"right\" && start == mEnd - mStart)\r\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\r\n            node = map[(i += 3) + 2];\r\n            collapse = \"right\";\r\n          }\r\n        break;\r\n      }\r\n    }\r\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\r\n  }\r\n\r\n  function getUsefulRect(rects, bias) {\r\n    var rect = nullRect\r\n    if (bias == \"left\") for (var i = 0; i < rects.length; i++) {\r\n      if ((rect = rects[i]).left != rect.right) break\r\n    } else for (var i = rects.length - 1; i >= 0; i--) {\r\n      if ((rect = rects[i]).left != rect.right) break\r\n    }\r\n    return rect\r\n  }\r\n\r\n\r\n  // Work around problem with bounding client rects on ranges being\r\n  // returned incorrectly when zoomed on IE10 and below.\r\n  function maybeUpdateRectForZooming(measure, rect) {\r\n    if (!window.screen || screen.logicalXDPI == null ||\r\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n      return rect;\r\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\r\n  }\r\n\r\n  function clearLineMeasurementCacheFor(lineView) {\r\n    if (lineView.measure) {\r\n      lineView.measure.cache = {};\r\n      lineView.measure.heights = null;\r\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\r\n        lineView.measure.caches[i] = {};\r\n    }\r\n  }\r\n\r\n\r\n  function pageScrollX() { \r\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft; \r\n  }\r\n  \r\n  function pageScrollY() { \r\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop; \r\n  }\r\n\r\n\r\n  function charCoords(cm, pos, context, lineObj, bias) {\r\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\r\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\r\n  }\r\n\r\n  // Returns a box for a given cursor position, which may have an\r\n  // 'other' property containing the position of the secondary cursor\r\n  // on a bidi boundary.\r\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n    lineObj = lineObj || getLine(cm.doc, pos.line);\r\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n    function get(ch, right) {\r\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\r\n      if (right) m.left = m.right; else m.right = m.left;\r\n      return intoCoordSystem(cm, lineObj, m, context);\r\n    }\r\n    function getBidi(ch, partPos) {\r\n      var part = order[partPos], right = part.level % 2;\r\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\r\n        part = order[--partPos];\r\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\r\n        right = true;\r\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\r\n        part = order[++partPos];\r\n        ch = bidiLeft(part) - part.level % 2;\r\n        right = false;\r\n      }\r\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\r\n      return get(ch, right);\r\n    }\r\n    var order = getOrder(lineObj), ch = pos.ch;\r\n    if (!order) return get(ch);\r\n    var partPos = getBidiPartAt(order, ch);\r\n    var val = getBidi(ch, partPos);\r\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\r\n    return val;\r\n  }\r\n\r\n  // Used to cheaply estimate the coordinates for a position. Used for\r\n  // intermediate scroll updates.\r\n  function estimateCoords(cm, pos) {\r\n    var left = 0, pos = clipPos(cm.doc, pos);\r\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\r\n    var lineObj = getLine(cm.doc, pos.line);\r\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\r\n  }\r\n\r\n  // Positions returned by coordsChar contain some extra information.\r\n  // xRel is the relative x position of the input coordinates compared\r\n  // to the found position (so xRel > 0 means the coordinates are to\r\n  // the right of the character position, for example). When outside\r\n  // is true, that means the coordinates lie outside the line's\r\n  // vertical range.\r\n  function PosWithInfo(line, ch, outside, xRel) {\r\n    var pos = Pos(line, ch);\r\n    pos.xRel = xRel;\r\n    if (outside) pos.outside = true;\r\n    return pos;\r\n  }\r\n\r\n\r\n\r\n\r\n\r\n});\r\n"]}