{"version":3,"sources":["primitives/util/bidi.js"],"names":["define","CoderCtor","charType","code","lowTypes","charAt","arabicTypes","BidiSpan","level","from","to","this","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","str","test","type","len","length","types","i","push","charCodeAt","prev","cur","end","replace","j","before","after","m","order","start","pos","at","splice","nstart","match","unshift","lst"],"mappings":"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","file":"../../../primitives/util/bidi.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  // BIDI HELPERS\r\n\r\n  function iterateBidiSections(order, from, to, f) {\r\n    if (!order) return f(from, to, \"ltr\");\r\n    var found = false;\r\n    for (var i = 0; i < order.length; ++i) {\r\n      var part = order[i];\r\n      if (part.from < to && part.to > from || from == to && part.to == from) {\r\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\r\n        found = true;\r\n      }\r\n    }\r\n    if (!found) f(from, to, \"ltr\");\r\n  }\r\n\r\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\r\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\r\n\r\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\r\n  function lineRight(line) {\r\n    var order = getOrder(line);\r\n    if (!order) return line.text.length;\r\n    return bidiRight(lst(order));\r\n  }\r\n\r\n  function lineStart(cm, lineN) {\r\n    var line = getLine(cm.doc, lineN);\r\n    var visual = visualLine(line);\r\n    if (visual != line) lineN = lineNo(visual);\r\n    var order = getOrder(visual);\r\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\r\n    return Pos(lineN, ch);\r\n  }\r\n  function lineEnd(cm, lineN) {\r\n    var merged, line = getLine(cm.doc, lineN);\r\n    while (merged = collapsedSpanAtEnd(line)) {\r\n      line = merged.find(1, true).line;\r\n      lineN = null;\r\n    }\r\n    var order = getOrder(line);\r\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\r\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\r\n  }\r\n  function lineStartSmart(cm, pos) {\r\n    var start = lineStart(cm, pos.line);\r\n    var line = getLine(cm.doc, start.line);\r\n    var order = getOrder(line);\r\n    if (!order || order[0].level == 0) {\r\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n      return Pos(start.line, inWS ? 0 : firstNonWS);\r\n    }\r\n    return start;\r\n  }\r\n\r\n  function compareBidiLevel(order, a, b) {\r\n    var linedir = order[0].level;\r\n    if (a == linedir) return true;\r\n    if (b == linedir) return false;\r\n    return a < b;\r\n  }\r\n  var bidiOther;\r\n  function getBidiPartAt(order, pos) {\r\n    bidiOther = null;\r\n    for (var i = 0, found; i < order.length; ++i) {\r\n      var cur = order[i];\r\n      if (cur.from < pos && cur.to > pos) return i;\r\n      if ((cur.from == pos || cur.to == pos)) {\r\n        if (found == null) {\r\n          found = i;\r\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\r\n          if (cur.from != cur.to) bidiOther = found;\r\n          return i;\r\n        } else {\r\n          if (cur.from != cur.to) bidiOther = i;\r\n          return found;\r\n        }\r\n      }\r\n    }\r\n    return found;\r\n  }\r\n\r\n  function moveInLine(line, pos, dir, byUnit) {\r\n    if (!byUnit) return pos + dir;\r\n    do pos += dir;\r\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\r\n    return pos;\r\n  }\r\n\r\n  // This is needed in order to move 'visually' through bi-directional\r\n  // text -- i.e., pressing left should make the cursor go left, even\r\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\r\n  // LTR text touch each other. This often requires the cursor offset\r\n  // to move more than one unit, in order to visually move one unit.\r\n  function moveVisually(line, start, dir, byUnit) {\r\n    var bidi = getOrder(line);\r\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\r\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\r\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\r\n\r\n    for (;;) {\r\n      if (target > part.from && target < part.to) return target;\r\n      if (target == part.from || target == part.to) {\r\n        if (getBidiPartAt(bidi, target) == pos) return target;\r\n        part = bidi[pos += dir];\r\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\r\n      } else {\r\n        part = bidi[pos += dir];\r\n        if (!part) return null;\r\n        if ((dir > 0) == part.level % 2)\r\n          target = moveInLine(line, part.to, -1, byUnit);\r\n        else\r\n          target = moveInLine(line, part.from, 1, byUnit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moveLogically(line, start, dir, byUnit) {\r\n    var target = start + dir;\r\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\r\n    return target < 0 || target > line.text.length ? null : target;\r\n  }\r\n\r\n  // Bidirectional ordering algorithm\r\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n  // that this (partially) implements.\r\n\r\n  // One-char codes used for character types:\r\n  // L (L):   Left-to-Right\r\n  // R (R):   Right-to-Left\r\n  // r (AL):  Right-to-Left Arabic\r\n  // 1 (EN):  European Number\r\n  // + (ES):  European Number Separator\r\n  // % (ET):  European Number Terminator\r\n  // n (AN):  Arabic Number\r\n  // , (CS):  Common Number Separator\r\n  // m (NSM): Non-Spacing Mark\r\n  // b (BN):  Boundary Neutral\r\n  // s (B):   Paragraph Separator\r\n  // t (S):   Segment Separator\r\n  // w (WS):  Whitespace\r\n  // N (ON):  Other Neutrals\r\n\r\n  // Returns null if characters are ordered as they appear\r\n  // (left-to-right), or an array of sections ({from, to, level}\r\n  // objects) in the order in which they occur visually.\r\n  var bidiOrdering = (function() {\r\n    // Character types for codepoints 0 to 0xff\r\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\r\n    // Character types for codepoints 0x600 to 0x6ff\r\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\r\n    function charType(code) {\r\n      if (code <= 0xf7) return lowTypes.charAt(code);\r\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\r\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\r\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\r\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\r\n      else if (code == 0x200c) return \"b\";\r\n      else return \"L\";\r\n    }\r\n\r\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n    // Browsers seem to always treat the boundaries of block elements as being L.\r\n    var outerType = \"L\";\r\n\r\n    function BidiSpan(level, from, to) {\r\n      this.level = level;\r\n      this.from = from; this.to = to;\r\n    }\r\n\r\n    return function(str) {\r\n      if (!bidiRE.test(str)) return false;\r\n      var len = str.length, types = [];\r\n      for (var i = 0, type; i < len; ++i)\r\n        types.push(type = charType(str.charCodeAt(i)));\r\n\r\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n      // change the type of the NSM to the type of the previous\r\n      // character. If the NSM is at the start of the level run, it will\r\n      // get the type of sor.\r\n      for (var i = 0, prev = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \"m\") types[i] = prev;\r\n        else prev = type;\r\n      }\r\n\r\n      // W2. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, AL, or sor) is found. If an\r\n      // AL is found, change the type of the European number to Arabic\r\n      // number.\r\n      // W3. Change all ALs to R.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\r\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\r\n      }\r\n\r\n      // W4. A single European separator between two European numbers\r\n      // changes to a European number. A single common separator between\r\n      // two numbers of the same type changes to that type.\r\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\r\n        var type = types[i];\r\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\r\n        else if (type == \",\" && prev == types[i+1] &&\r\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\r\n        prev = type;\r\n      }\r\n\r\n      // W5. A sequence of European terminators adjacent to European\r\n      // numbers changes to all European numbers.\r\n      // W6. Otherwise, separators and terminators change to Other\r\n      // Neutral.\r\n      for (var i = 0; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == \",\") types[i] = \"N\";\r\n        else if (type == \"%\") {\r\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\r\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // W7. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, or sor) is found. If an L is\r\n      // found, then change the type of the European number to L.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\r\n        else if (isStrong.test(type)) cur = type;\r\n      }\r\n\r\n      // N1. A sequence of neutrals takes the direction of the\r\n      // surrounding strong text if the text on both sides has the same\r\n      // direction. European and Arabic numbers act as if they were R in\r\n      // terms of their influence on neutrals. Start-of-level-run (sor)\r\n      // and end-of-level-run (eor) are used at level run boundaries.\r\n      // N2. Any remaining neutrals take the embedding direction.\r\n      for (var i = 0; i < len; ++i) {\r\n        if (isNeutral.test(types[i])) {\r\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\r\n          var before = (i ? types[i-1] : outerType) == \"L\";\r\n          var after = (end < len ? types[end] : outerType) == \"L\";\r\n          var replace = before || after ? \"L\" : \"R\";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // Here we depart from the documented algorithm, in order to avoid\r\n      // building up an actual levels array. Since there are only three\r\n      // levels (0, 1, 2) in an implementation that doesn't take\r\n      // explicit embedding into account, we can build up the order on\r\n      // the fly, without following the level-based algorithm.\r\n      var order = [], m;\r\n      for (var i = 0; i < len;) {\r\n        if (countsAsLeft.test(types[i])) {\r\n          var start = i;\r\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\r\n          order.push(new BidiSpan(0, start, i));\r\n        } else {\r\n          var pos = i, at = order.length;\r\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\r\n          for (var j = pos; j < i;) {\r\n            if (countsAsNum.test(types[j])) {\r\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\r\n              var nstart = j;\r\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\r\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\r\n              pos = j;\r\n            } else ++j;\r\n          }\r\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\r\n        }\r\n      }\r\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n        order[0].from = m[0].length;\r\n        order.unshift(new BidiSpan(0, 0, m[0].length));\r\n      }\r\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n        lst(order).to -= m[0].length;\r\n        order.push(new BidiSpan(0, len - m[0].length, len));\r\n      }\r\n      if (order[0].level == 2)\r\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\r\n      if (order[0].level != lst(order).level)\r\n        order.push(new BidiSpan(order[0].level, len, len));\r\n\r\n      return order;\r\n    };\r\n  })();\r\n\r\n  // THE END\r\n\r\n\r\n});\r\n"]}