{"version":3,"sources":["primitives/util/event.js"],"names":["define","CoderCtor","getHandlers","emitter","type","copy","arr","_handlers","length","slice","noHandlers","e_preventDefault","CodeMirror","e","preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","on","f","addEventListener","attachEvent","map","push","off","removeEventListener","detachEvent","handlers","i","splice","signal","args","Array","prototype","call","arguments","apply"],"mappings":";;;;;;;AAAAA,QACE,gBACA,SAASC,GA0DT,QAASC,GAAYC,EAASC,EAAMC,GAClC,GAAIC,GAAMH,EAAQI,WAAaJ,EAAQI,UAAUH,EACjD,OAAIC,GAAaC,GAAOA,EAAIE,OAAS,EAAIF,EAAIG,QAAUC,EAC3CJ,GAAOI,EAvDrB,GAAIC,GAAmBC,WAAWD,iBAAmB,SAASE,GACxDA,EAAEC,eAAgBD,EAAEC,iBACnBD,EAAEE,aAAc,GAGnBC,EAAoBJ,WAAWI,kBAAoB,SAASH,GAC1DA,EAAEI,gBAAiBJ,EAAEI,kBACpBJ,EAAEK,cAAe,GA4CpBR,GArCSE,WAAWO,OAAS,SAASN,GACxCF,EAAiBE,GACjBG,EAAkBH,IAuBXD,WAAWQ,GAAK,SAASjB,EAASC,EAAMiB,GAC/C,GAAIlB,EAAQmB,iBACVnB,EAAQmB,iBAAiBlB,EAAMiB,GAAG,OAC/B,IAAIlB,EAAQoB,YACfpB,EAAQoB,YAAY,KAAOnB,EAAMiB,OAC9B,CACH,GAAIG,GAAMrB,EAAQI,YAAcJ,EAAQI,cACpCD,EAAMkB,EAAIpB,KAAUoB,EAAIpB,MAC5BE,GAAImB,KAAKJ,QAWHT,YAAWc,IAAM,SAASvB,EAASC,EAAMiB,GACjD,GAAIlB,EAAQwB,oBACVxB,EAAQwB,oBAAoBvB,EAAMiB,GAAG,OAClC,IAAIlB,EAAQyB,YACfzB,EAAQyB,YAAY,KAAOxB,EAAMiB,OAGjC,KAAK,GADDQ,GAAW3B,EAAYC,EAASC,GAAM,GACjC0B,EAAI,EAAGA,EAAID,EAASrB,SAAUsB,EACrC,GAAID,EAASC,IAAMT,EAAG,CAAEQ,EAASE,OAAOD,EAAG,EAAI,SAIxClB,WAAWoB,OAAS,SAAS7B,EAASC,GACjD,GAAIyB,GAAW3B,EAAYC,EAASC,GAAM,EAE1C,IAAKyB,EAASrB,OAId,IAAK,GAFDyB,GAAOC,MAAMC,UAAU1B,MAAM2B,KAAKC,UAAW,GAExCP,EAAI,EAAGA,EAAID,EAASrB,SAAUsB,EACrCD,EAASC,GAAGQ,MAAM,KAAML","file":"../../../primitives/util/event.js","sourcesContent":["define([\r\n  \"../CoderCtor\"\r\n],function(CoderCtor) {\r\n  // EVENT UTILITIES\r\n\r\n  // Due to the fact that we still support jurassic IE versions, some\r\n  // compatibility wrappers are needed.\r\n\r\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\r\n    if (e.preventDefault) e.preventDefault();\r\n    else e.returnValue = false;\r\n  };\r\n  \r\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\r\n    if (e.stopPropagation) e.stopPropagation();\r\n    else e.cancelBubble = true;\r\n  };\r\n\r\n  function e_defaultPrevented(e) {\r\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\r\n  }\r\n\r\n  var e_stop = CodeMirror.e_stop = function(e) {\r\n    e_preventDefault(e); \r\n    e_stopPropagation(e);\r\n  };\r\n\r\n  function e_target(e) {\r\n    return e.target || e.srcElement;\r\n  }\r\n  \r\n  function e_button(e) {\r\n    var b = e.which;\r\n    if (b == null) {\r\n      if (e.button & 1) b = 1;\r\n      else if (e.button & 2) b = 3;\r\n      else if (e.button & 4) b = 2;\r\n    }\r\n    if (mac && e.ctrlKey && b == 1) b = 3;\r\n    return b;\r\n  }\r\n\r\n  // EVENT HANDLING\r\n\r\n  // Lightweight event framework. on/off also work on DOM nodes,\r\n  // registering native DOM handlers.\r\n\r\n  var on = CodeMirror.on = function(emitter, type, f) {\r\n    if (emitter.addEventListener)\r\n      emitter.addEventListener(type, f, false);\r\n    else if (emitter.attachEvent)\r\n      emitter.attachEvent(\"on\" + type, f);\r\n    else {\r\n      var map = emitter._handlers || (emitter._handlers = {});\r\n      var arr = map[type] || (map[type] = []);\r\n      arr.push(f);\r\n    }\r\n  };\r\n\r\n  var noHandlers = []\r\n  function getHandlers(emitter, type, copy) {\r\n    var arr = emitter._handlers && emitter._handlers[type]\r\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\r\n    else return arr || noHandlers\r\n  }\r\n\r\n  var off = CodeMirror.off = function(emitter, type, f) {\r\n    if (emitter.removeEventListener)\r\n      emitter.removeEventListener(type, f, false);\r\n    else if (emitter.detachEvent)\r\n      emitter.detachEvent(\"on\" + type, f);\r\n    else {\r\n      var handlers = getHandlers(emitter, type, false)\r\n      for (var i = 0; i < handlers.length; ++i)\r\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\r\n    }\r\n  };\r\n\r\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\r\n    var handlers = getHandlers(emitter, type, true)\r\n    \r\n    if (!handlers.length) return;\r\n    \r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    \r\n    for (var i = 0; i < handlers.length; ++i) {\r\n      handlers[i].apply(null, args);\r\n    }\r\n  };\r\n\r\n  var orphanDelayedCallbacks = null;\r\n\r\n  // Often, we want to signal events at a point where we are in the\r\n  // middle of some work, but don't want the handler to start calling\r\n  // other methods on the editor, which might be in an inconsistent\r\n  // state or simply not expect any other events to happen.\r\n  // signalLater looks whether there are any handlers, and schedules\r\n  // them to be executed when the last operation ends, or, if no\r\n  // operation is active, when a timeout fires.\r\n  function signalLater(emitter, type /*, values...*/) {\r\n    var arr = getHandlers(emitter, type, false)\r\n    if (!arr.length) return;\r\n    var args = Array.prototype.slice.call(arguments, 2), list;\r\n    if (operationGroup) {\r\n      list = operationGroup.delayedCallbacks;\r\n    } else if (orphanDelayedCallbacks) {\r\n      list = orphanDelayedCallbacks;\r\n    } else {\r\n      list = orphanDelayedCallbacks = [];\r\n      setTimeout(fireOrphanDelayed, 0);\r\n    }\r\n    \r\n    function bnd(f) {\r\n      return function(){f.apply(null, args);};\r\n    };\r\n    \r\n    for (var i = 0; i < arr.length; ++i)\r\n      list.push(bnd(arr[i]));\r\n  }\r\n\r\n  function fireOrphanDelayed() {\r\n    var delayed = orphanDelayedCallbacks;\r\n    orphanDelayedCallbacks = null;\r\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\r\n  }\r\n\r\n  // The DOM events that CodeMirror handles can be overridden by\r\n  // registering a (non-DOM) handler on the editor for the event name,\r\n  // and preventDefault-ing the event in that handler.\r\n  function signalDOMEvent(cm, e, override) {\r\n    if (typeof e == \"string\")\r\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\r\n    signal(cm, override || e.type, cm, e);\r\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\r\n  }\r\n\r\n  function signalCursorActivity(cm) {\r\n    var arr = cm._handlers && cm._handlers.cursorActivity;\r\n    if (!arr) return;\r\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\r\n      set.push(arr[i]);\r\n  }\r\n\r\n  function hasHandler(emitter, type) {\r\n    return getHandlers(emitter, type).length > 0\r\n  }\r\n\r\n  // Add on and off methods to a construCoderCtor's prototype, to make\r\n  // registering events on such objects more convenient.\r\n  function eventMixin(ctor) {\r\n    ctor.prototype.on = function(type, f) {\r\n      on(this, type, f);\r\n    };\r\n    \r\n    ctor.prototype.off = function(type, f) {\r\n      off(this, type, f);\r\n    };\r\n  }\r\n\r\n});\r\n"]}